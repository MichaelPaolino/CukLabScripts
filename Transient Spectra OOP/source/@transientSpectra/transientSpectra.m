classdef transientSpectra
	properties
        spectra = doubleWithUnits();  %(doubleWithUnits) array with dims [pixels, delays, rpts, grating pos, schemes]
        spectra_std = doubleWithUnits(); %(doubleWithUnits) std array for one shot cycle (e.g. 2 frames) with dims [pixels, delays, rpts, grating pos, schemes]
        wavelengths = doubleWithUnits();  %(doubleWithUnits) array with dims [pixels, grating pos]
        delays = doubleWithUnits();   %(doubleWithUnits) array with dims [delays, repeats, grating pos]
        t0 = doubleWithUnits(); %(doubleWithUnits) array with dims [pixels searched, repeats, grating pos]
        gPos = zeros(); %(double) array of grating positions with dims [nGPos,1]
        
        name = '';  %(char) filename used to generate the object
        shortName = ''; %(char) user assigned name for legend display and exporting
        description = ''; %(char) description from the acquisition program
                         
        schemes = {}; %(cell array of char) that lists data schemes inside the object
                                
        %size information
        sizes = struct('nRpts', 0, ...  %struct with fields type double defining the size of spectra dimensions
                       'nGPos', 0, ...
                       'nSchemes', 0, ...
                       'nDelays', 0, ...
                       'nPixels', 0);
    end
    
    properties (Access = protected)
       flags = struct('isDefault', true,...%(logical) is this a default object (i.e. no data loaded)?
                      't0corr', false);    %(logical) has the t0 been corrected?
                      
       displayNames = nameRule(); %(nameRule) object containing generic naming rules for legend and export display
    end
    
    %% Constructor, load, export, get and set methods
    methods

        %%**CONSTRUCTOR METHODS**%%
        function obj = transientSpectra(varargin)
        % TRANSIENTSPECTRA objects are designed to handle spectra generated by 
        % transient spectroscopy setups. This includes data about spectra, its 
        % variance, delays, wavelengths, grating positions, and data chopping 
        % schemes used to generate the spectra.
        % 
        % This constructor accepts single inputs or a cell array of inputs of the 
        % correct type. If a cell array is passed, the constructor will generate an
        % object array that is the same size as the first argument cell array. 
        % Additional argument's singleton dimentions will be expanded to match the 
        % size of the first argument.
        %
        % obj = TRANSIENTSPECTRA(); 
        %	Construct a default TRANSIENTSPECTRA object.
        %
        % obj = TRANSIENTSPECTRA(filePath);
        %	Construct a TRANSIENTSPECTRA object from a dataHolder .mat file in
        %	filePath by calling convertDH. convertDH is designed to able to handle
        %	data generated by any version of the acquisition program.
        %
        % obj = TRANSIENTSPECTRA(obj);
        %	Converts a child object obj to the TRANSIENTSPECTRA class.
        %
        % obj = TRANSIENTSPECTRA(__, varargin)
        %	Constructs a TRANSIENTSPECTRA object with additional options specified
        %	by varargin. varargin is a comma sperated list of keywords and/or
        %	name-value pairs. 
        %
        % Name-Value pairs:
        %   'shortName' (char or cell of char) set the object's short name
        %   'loadType' (char or cell of char) set the method for importing data.
        %       The default loadType method is 'dataHolder'. Implpemented methods 
        %       for the transientSpectra class are:
        %           'dataHolder': import .mat files saved by the LabVIEW MATLAB API
        %   
        % TRANSIENTSPECTRA units are:
        %   Spectra: 
        %       (OD): Log-scale optical density for absorption
        %       (mOD): 1000x OD unit
        %       
        %   Delays:
        %       (fs): pump-probe delays in fs
        %       (ps): ... in ps
        %       (ns): ... in ns
        %       (us): ... in us
        %
        %   Wavelengths: 
        %       (nm): Spectrometer calibration in nm wavelength
        %       (um): ... in um wavelength
        %       (eV): ... in photon energy, electron volts
        %       (ecm-1): ... in photon energy, wavenumbers
        %
        % The default units for a transientSpectra object are mOD, ps, and
        % nm
        %
        % See also: DOUBLEWITHUNITS
                   
           if nargin==0 % construct a default object
                % do nothing              
           else % data is available, build non-default object array
                              
               % Use input parser to parse user arguments
               p = inputParser;
               p.FunctionName = 'transientSpectra';
               p.StructExpand = false;
               
               % Use valVarCell to validate both cell and non-cell inputs
               p.addRequired('dataSource',@(p) valVarCell(p, @(c) ischar(c))); % Must be a char array or cell array of char array
               p.addParameter('shortName','', @(p) valVarCell(p,@(c) ischar(c))); % Must be a char array or cell array of char array
               p.addParameter('loadType','dataHolder', @(p) valVarCell(p,@(c) ischar(c))); % Must be a char array or cell array of char array
               
               % parse inputs and store results in struct p.Results
               p.parse(varargin{:}); 
               
               % convert parsed results into struct whose elements are cells
               results = ensureCellVals(p.Results);
               
               % determine desired size of the object based on size of dataSource cell array
               argSize = size(results.dataSource);    %this will be the final size of the object data
               argNumel = numel(results.dataSource);  %for easy looping, the number of elements
               results.dataSource = results.dataSource(:); %for easy looping, convert dataSource into cell vector [n x 1]
                
               % ensure that the cell array size matches the object size by and convert into column vector
               results.loadType = explicitExpand(results.loadType, argSize);
               results.loadType = results.loadType(:); %for easy looping, convert shortName into cell vector

               results.shortName = explicitExpand(results.shortName, argSize);
               results.shortName = results.shortName(:); %for easy looping, convert shortName into cell vector
               
               % Create object array by loading data into last element first
               % (this is recommended in MATLAB help)
               obj(argNumel) = obj(1).importData(results.dataSource{argNumel},results.loadType{argNumel});
               
               % Loop over remaining elemenets and update object member data
               for objInd = 1:argNumel-1
                   obj(objInd) = obj(objInd).importData(results.dataSource{objInd},results.loadType{objInd});
               end
               
               % Update any optional paramters
               for objInd = 1:argNumel
                   % Update short name if it exists
                   if ~isempty(results.shortName{objInd})
                        obj(objInd).shortName = results.shortName{objInd};
                   end
                   
                   %If data has been loaded succesfully, set each element default object flag to false
                   obj(objInd).flags.isDefault = false;
               end
               
               % Assign units to relevant numeric data. This method can be overriden in a subclass
               % Note: assignUnits does not support object array functionality because different 
               % object array elements may have different unit assignments.
               for objInd = 1:argNumel
                   obj(objInd) = obj(objInd).assignUnits();
               end
               
               %Set default units
               obj = obj.setUnits('nm','ps','mOD');
               
               %reshape object to match input array shape
               obj = reshape(obj,argSize);
               
           end %nargin
        end %constructor
               
        % EXPORT the object data to an igor compatible .mat file
        [outputStruct, filePath] = export(obj,filePath,varargin)
        
        %%**GET-SET METHODS**%%
        %Data units
        function obj = setUnits(obj,wavelengthUnit,delayUnit,spectraUnit)
        % SETUNITS sets the units for the wavelengths, delays, and spectra.
        % Use an empty char array, [] or '', as a flag to skip changing the unit.
        % Changing the unit updates the numeric values in the relavent arrays.
        %
        % obj = obj.SETUNITS(wavelengthUnit,delayUnit,spectraUnit)
        %   Changes the units for wavelengths, delays, and spectra
        %
        % obj = obj.SETUNITS([],[],spectraUnit)
        %   Changes the units for spectra only. Any combination of brakets is
        %   allowed to select which units need to be changed.
        %
        % See Also: GETUNITS, DOUBLEWITHUNITS
           
           % Formtat object array dims into a column for easy looping
           objSize = size(obj);
           objNumel = numel(obj);
           obj = obj(:);
           
           %loop through each object and update units
           for objInd = 1:objNumel
               if ~isempty(wavelengthUnit)
                   obj(objInd).wavelengths.unit = wavelengthUnit;
               end

               if ~isempty(delayUnit)
                   obj(objInd).delays.unit = delayUnit;
                   obj(objInd).t0.unit = delayUnit;
               end

               if ~isempty(spectraUnit)
                   obj(objInd).spectra.unit = spectraUnit;
                   obj(objInd).spectra_std.unit = spectraUnit;
               end
           end
           
           %convert object back to original array dims
           obj = reshape(obj,objSize);
        end
        
        function [wavelengthUnit, delayUnit, spectraUnit] = getUnits(obj)
        % GETUNITS returns the current wavelength, delay, and signal units for the
        % object array. If the units are the same for all elements, the units are
        % returned as char arrays. If the units are different for any element, all
        % outputs are returned as cell arrays of chars. The returned cell arrays
        % are the same size as the object array.
        %
        % [wavelengthUnit, delayUnit, spectraUnit] = GETUNITS(obj)
        %   Returns char arrays or cell arrays containing doubleWithUnits unit
        %   short names for the wavelengths, delays, and spectra.
        %
        % See Also: SETUNITS, DOUBLEWITHUNITS
            
            % Formtat object array dims into a column for easy looping
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            
            %initialize wavelength, delay, and spectra output for loop
            wavelengthUnit = cell(objNumel,1);
            delayUnit = cell(objNumel,1);
            spectraUnit = cell(objNumel,1);
            
            %loop over objects in array and retrive units 
            for objInd = 1:objNumel
                wavelengthUnit{objInd} = obj(objInd).wavelengths.unit;
                delayUnit{objInd} = obj(objInd).delays.unit;
                spectraUnit{objInd} = obj(objInd).spectra.unit;
            end
            
            %check to see if all units are the same for all objects
            sameWlUnit = all(strcmp(wavelengthUnit{1},wavelengthUnit));
            sameDelayUnit = all(strcmp(delayUnit{1},delayUnit));
            sameSpectraUnit = all(strcmp(spectraUnit{1},spectraUnit));
            allUnitsSame = sameWlUnit && sameDelayUnit && sameSpectraUnit;
            
            %Decide on whether to return one unit or cell array of units
            if allUnitsSame
                wavelengthUnit = wavelengthUnit{1};
                delayUnit = delayUnit{1};
                spectraUnit = spectraUnit{1};
            else
                wavelengthUnit = reshape(wavelengthUnit,objSize);
                delayUnit = reshape(delayUnit,objSize);
                spectraUnit = reshape(spectraUnit,objSize);
            end

        end
        
        %Schemes manipulation
        function obj = getScheme(obj, targetScheme)
        % GETSCHEME returns an object array that only contains the target scheme.
        % The target scheme can be either the char name of the scheme or its index.
        % 
        % obj = obj.GETSCHEME(targetScheme)
        %   Returns an object array with data that corresponds to the targetScheme
        %   name or index.
        %
        % See Also: GETUNIQUELABELS, GETCOMMONLABELS, CONTAINSLABEL, SPLITSCHEMES        
        
            %prepare object array for looping
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            
            %loop over object elements
            for objInd = 1:objNumel
                %compare target schemes against available schemes in object
                if ischar(targetScheme) %if scheme is a name, convert it to an index
                    schemeInd = strcmp(targetScheme,obj(objInd).schemes);
                    assert(any(schemeInd),[targetScheme ' was not found for object element ' num2str(objInd) '.']);
                else %if scheme is already an index
                    schemeInd = targetScheme;
                    assert(schemeInd<=length(obj(objInd).schemes),[num2str(schemeInd) ' is greater than the number ',...
                                                                 'of availble schemes for object element' num2str(objInd) '.']);
                end
                
                %update object properties
                obj(objInd).spectra.data = obj(objInd).spectra.data(:,:,:,:,schemeInd);
                obj(objInd).spectra_std.data = obj(objInd).spectra_std.data(:,:,:,:,schemeInd);
                obj(objInd).schemes = obj(objInd).schemes(schemeInd);
                obj(objInd).sizes.nSchemes = 1;
            end
            
            %return obj back to its original dims
            obj = reshape(obj, objSize);
        end   
                
        function [logicalOut, ind] = containsLabel(obj, labelName, labelValue)
        % CONTAINSLABEL returns a logical array whose elements are true when the
        % object array element member data contains the target value. The output 
        % logical array is the same size as the object array.
        %
        % logicalOut = obj.CONTAINSLABEL(labelName, labelValue)
        %   Returns an logical array logicalOut of size [objSize]. Elements of 
        %   objSize are true when obj(objElem).(labelName) contains labelValue.  
        %
        % [logicalOut, ind] = obj.CONTAINSLABEL(labelName, labelValue)
        %   Returns an additional logical ind that indicates at which index the 
        %   target label is present. The size of ind is:
        %   [max number of schemes in any object element, [objSize]]
        %
        % See Also: GETSCHEME, GETUNIQUELABELS, GETCOMMONLABELS, SPLITSCHEMES

            %prepare object array for data access
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            
            %a cell array of all labels for each object array element
            labelList = {obj.(labelName)}; 
            
            %loop over object elements to see if its label list contains the labelValue
            logicalOut = false(objNumel,1);
            ind = false(max(cellfun(@length,labelList)),objNumel);
            for ii = 1:objNumel
               if iscell(labelList{ii}) && ischar(labelValue)
                   tmp = strcmp(labelValue,labelList{ii});
               elseif isnumeric(labelList{ii}) && isscalar(labelValue)
                   tmp = labelList{ii} == labelValue;
               else
                   error('labelName and labelValue types do not match.'); 
               end
               ind(1:length(tmp),ii) = tmp;
               logicalOut(ii) = any(ind(:,ii));
            end
            
            %convert the array size of logical out to the original object array size
            logicalOut = reshape(logicalOut,objSize);
            ind = reshape(ind,[size(ind,1),objSize]);
        end
        
        function [uniqueLabels, ind] = getUniqueLabels(obj, labelName)
        % GETUNIQUELABELS returns a cell array of all unique label values contained
        % in the object array member data.
        %
        % uniqueLabels = obj.GETUNIQUELABELS(labelName)
        %   Returns an array that contain the unique label values specified by
        %   labelName in obj(:).(labelName). The returned array type is the same as
        %   the label type in the object.
        %
        % [uniqueLabels, ind] = obj.GETUNIQUELABELS(labelName)
        %   Returns an additional logical ind that indicates in dim 1 at which index
        %   each  unique label is present. The size of ind is:
        %   [max number of labels in any object element, nUniqueLAbels, [objSize]]
        %
        % See Also: GETSCHEME, GETCOMMONLABELS, CONTAINSLABEL, SPLITSCHEMES
        
            %prepare object array for data access
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            
            %Get unique schemes out of the object
            labelList = {obj.(labelName)};
            if iscell(labelList{1})
                labelListAll = vertcat(labelList{:}); %a cell array of all schemes with char as elements
            elseif isnumeric(labelList{1})
                labelListAll = cell2mat(labelList);
            else
                error('Encountered unsupported label type.');
            end
            uniqueLabels = unique(labelListAll); %unique schemes inside the object array
            
            %return index of unique label
            nUniqueLabels = length(uniqueLabels);          
            ind = false(max(cellfun(@length,labelList)),nUniqueLabels,objNumel);
            for ii = 1:nUniqueLabels
                if iscell(uniqueLabels(ii))
                    [~,ind(:,ii,:)] = containsLabel(obj,labelName,uniqueLabels{ii});
                elseif isnumeric(uniqueLabels(ii))
                    [~,ind(:,ii,:)] = containsLabel(obj,labelName,uniqueLabels(ii));
                else
                    error('Encountered unsupported label type.');
                end
            end
            
            %return indecies as original size of object
            %[scheme index, unique scheme, [objSize]]
            ind = reshape(ind, [size(ind,1), size(ind,2), objSize]);

        end
        
        function [commonLabels, ind] = getCommonLabels(obj, labelName)
        % GETCOMMONLABELS returns a cell array of scheme names that are common to 
        % all elements of the object array.
        %
        % commonSchemes = obj.GETCOMMONSCHEMES()
        %   Returns a cell array of chars that contain the common scheme names in 
        %   the obj array.
        %
        % [commonSchemes, ind] = obj.GETCOMMONSCHEMES()
        %   Returns an additional logical ind that indicates in dim 1 at which 
        %   index the scheme is present. The size of ind is:
        %   [max number of schemes in any object element, nCommonSchemes,[objSize]]
        %
        % See Also: GETSCHEME, GETUNIQUELABELS, CONTAINSLABEL, SPLITSCHEMES

            %prepare object array for data access
            objSize = size(obj);
            obj = obj(:);
            
            %get unique schemes and their indicies from the object array
            [uniqueLabels, ind] = obj.getUniqueLabels(labelName);
            
            %schemes that are common to all elements of the object array
            %along object element dim 3 and scheme index dim 1
            commonInd = all(any(ind,1),3);
            commonLabels = uniqueLabels(commonInd(:));
            ind = ind(:,commonInd(:),:);
            
            %return indecies as original size of object
            %[scheme index, unique scheme, [objSize]]
            ind = reshape(ind, [size(ind,1), size(ind,2), objSize]);
        end
        
        function [objOut, schemeList] = splitSchemes(objIn, varargin)
        % SPLITSCHEMES splits the input object's schemes into an array of objects 
        % where each element contains a unique scheme. If the object is already an
        % array, the method will perform the split into a new dim as the last dim.
        % This method updates the spectra, spectra_std, schemes, and sizes
        % properties.
        %
        % objOut = SPLITSCHEMES(objIn)
        %   Splits objIn by scheme into an array of size [[size(objIn)], nSchemes].
        %   If objIn is a row vector, then the output is [length(objIn), nSchemes].
        %
        % objOut = SPLITSCHEMES(objIn, varargin)
        %   Performs the split with a subset of schemes defined by varargin, which
        %   is a comma separated list whose elements contain char schemes,
        %   keywords, or name-value pairs. If there are no keywords or name-value 
        %   pairs, SPLITSCHEMES will return a split object containing the schemes 
        %   listed in varargin.
        %
        %   Keywords:
        %      '-drop' performs the split but excludes schemes in the list
        %
        %   Name-Value pairs
        %       '-search', partialName: performs the split but keeps (or drops)
        %       scheme names containing char partialName.
        %
        % [objOut, schemeList] = SPLITSCHEMES(...)
        %   Additionally returns schemeList, which is a cell array of char that
        %   contains the scheme name of each array element along the new dim.
        %
        % See Also: GETSCHEME, GETUNIQUELABELS, GETCOMMONLABELS,
        % CONTAINSLABEL

        %%--PRE_PROCESSING OF OBJECT AND SCHEMES--%%
            %Get object size to determine final output object size
            if isvector(objIn)
                %on output, first dim will be the original vector length, and the 2nd dim will be the scheme size
                objSize = length(objIn); 
            else
                %on output, the obj size will be preserved and the scheme size will be appended as the last dim
                objSize = size(objIn);   
            end
            
            %prepare object array for looping
            objNumel = numel(objIn);
            objIn = objIn(:);
            
            %schemes that are common to all elements of the object array.
            %Only these schemes, or a subset, can be returned
            schemeList = objIn.getCommonLabels('schemes');
            nSchemes = length(schemeList);
            
            assert(nSchemes>0,'No common schemes found. Schemes cannot be split of object array does not have common schemes');
            
        %%--PARSE USER INPUT--%%
            %default options for user input
            searchFlag = false;
            dropFlag = false;
            
            %parse varargin
            argInd = 1;
            userSchemes = {};
            while argInd <= length(varargin)
                if ischar(varargin{argInd}) %User is either using keyword, name-value pair, or listing the schemes to keep
                    switch varargin{argInd}
                        case '-search'  %search schemeList
                            searchChar = varargin{argInd+1}; %to do: check that next input is a string
                            searchFlag = true;
                            argInd = argInd + 2;
                        case '-drop' %user wants to drop schemes from search results or list
                            dropFlag = true;
                            argInd = argInd + 1;
                        otherwise %user is listing specific schemes to keep, add to scheme register
                            userSchemes = [userSchemes; varargin(argInd)];
                            argInd = argInd + 1;
                    end
                elseif isvector(varargin{argInd})   %User passed a vector of scheme indicies
                    userSchemes = schemeList(varargin{argInd});
                    break;  %no other inputs are allowed with vector input
                else
                    error('Invalid input. Expected keyword, name-value pair, list of schemes, or vector of scheme indicies');
                end
            end       
            
            %search common scheme against user input and add to userSchemes
            if searchFlag
                foundStr = contains(schemeList,searchChar,'IgnoreCase',true);
                userSchemes = [userSchemes; schemeList(foundStr)];
            end
            
            %if user made a custom selection
            if ~isempty(userSchemes)
                %remove duplicate user schemes
                userSchemes = unique(userSchemes);
                
                %check whether user schemes are valid
                schemeInd = false(length(userSchemes),nSchemes);
                for ii = 1:length(userSchemes)
                   schemeInd(ii,:) = strcmp(userSchemes{ii},schemeList); 
                   assert(any(schemeInd(ii,:)), ['Could not find scheme: ' userSchemes{ii} '. Available schemes are ' strjoin(schemeList,', ') '.']);
                end
                
                %once all schemes are validated, select subset of schemeList
                if dropFlag %drop user schemes from schemeList
                    schemeList = schemeList(~any(schemeInd,1),1);
                else %use user schemes instead of schemeList
                    schemeList = userSchemes;
                end
                
                nSchemes = length(schemeList);
            end
        
        %%--GENERATE OBJECT ARRAY WITH SPLIT SCHEMES--%%
            %initialize output object array, which will be [numel,nSchemes]
            objOut(objNumel,nSchemes) = objIn(objNumel);
            
            %loop over object elements
            for ii = 1:nSchemes
                objOut(:,ii) = objIn.getScheme(schemeList{ii});
            end
            
            %return obj back to its original dims
            objOut = reshape(objOut, [objSize, nSchemes]);
        end
    end
    
    %% Protected methods that define the inner workings of the class
    %Use constructor to load data.
    methods (Access = protected)

        function obj = importData(obj,myPath,loadType)
        % IMPORTDATA loads a file from a path using the import method specified by
        % a load type and populates the objects member data. This method is 
        % designed to dispatch the correct import/load method and not implement a
        % specific import/load routine, therby allowing the developer to override 
        % import implementations in subclasses. 
        % 
        % Override this method to implement subclass-specific load types. The
        % recommended call order is for the subclass to run its specific
        % implementation first using a switch...case statement and then call the 
        % superclass implementation in the otherwise clause. This superclass method
        % returns an error when an unsupported load type is encountered.
        %
        % obj = obj.LOADPATH(path, loadType);
        %   Loads data into the object from path depending on the load type. Load
        %   types that are supported for transientSpectra are:
        %   'dataHolder': a .mat file containing saved data from the dataHolder
        %       class in the forms of a dh_static and dh_array struct.
        %
        % See Also: CONVERTDH
            
            switch loadType   %check the variable class
                case 'dataHolder'    %this should be saved dataholder object that contains structs dh_static and dh_array
                    % Use ConvertDH to load object data from path
                    obj = convertDH(obj,myPath);
                otherwise
                   error('Unsupported load type: %s.', loadType);
            end
        end

        % Note: in unit testing this runs too slow because FSRS/TR matlab
        % files require uncompressing the full file before checking the
        % contents
         function loadType = determineLoadType(obj, myPath, defaultType)
        % DETERMINELOADTYPE returns an object-specific type string that informs the
        % loadPath method on which load type to execute. If a file is given without
        % its extention (.mat or .bin files), this method will attempt to determine
        % its extention. If the load type cannot be determined, this method returns
        % the file extention.
        %
        % Override this method to return subclass-specific load types. This method
        % works best when its superclass call is done first and the subclass call
        % contains parsing code for load types not handled in the superclass call.
        %
        % The TRANSIENTSPECTRA call of DETERIMNELOADTYPES supports the following
        % load types:
        %   'dataHolder': a *.mat file with dh_array and dh_static structs
        %   'tsObj': a *.mat file with that contains a transientSpectra object
            
            % Determine file extention
            [~,~,fileExt] = fileparts(myPath);

            % For .mat files (or files without extention, which can also be .mat files when using load)
            if strcmp(fileExt,'.mat') || isempty(fileExt)
                mVars = whos('-file',myPath); % Get attributes for variables saved in file

                % Check that variables exist
                if isempty(mVars) %The file does not exist or is not a .mat file
                    loadType = fileExt;
                else %The file exists and has variables inside it
                    if any(strcmp({mVars.name},'dh_static')) && any(strcmp({mVars.name},'dh_array'))
                        loadType = 'dataHolder';
                    else
                        loadType = '.mat';
                    end
                end 
            else
                loadType = fileExt;
            end
         end
        
        % CONVERTDH converts a data holder into a transientSpectra. 
        % See convertDH.m for generic implementation. Override this method in 
        % subclasses for specific implementation.
        obj = convertDH(obj, dh_static, dh_array);
        
        function [obj,unitRules] = assignUnits(obj)
        % ASSIGNUNITS assigns units to relevant numeric member data in the specific
        % class. Override this method in subclasses to assign additional units.
        % The recommended use is to call the superclass method in the subclass before 
        % assigning additional units. Assign additional units by adding units to the 
        % output struct, unitRules, and calling the doubleWithUnits constructor.
        % Note: This method does not support object array functionality
        % because different objects may have different unit assignments.
        %
        % obj = obj.assignUnits()
        %   Protected method designed for override that assigns units in the
        %   constructor call.
        %
        % [obj, unitRules] = obj.assignUnits()
        %   Additionaly returns a structure with the unit rules
        %
        % See Also: DOUBLEWITHUNITS
        
            %define unit rules for spectra, delays, and wavelengths for the transientSpectra class
            %spectra
            spectraRules = doubleWithUnits([],'OD','\DeltaAbs. (OD)');
            spectraRules = spectraRules.addRule('mOD','\DeltaAbs. (mOD)',@(f) 1e3*f, @(f) 1e-3*f);

            %delays
            delayRules = doubleWithUnits([],'ps','Delay (ps)');
            delayRules = delayRules.addRule('fs','Delay (fs)',@(f) 1e3*f, @(f) 1e-3*f);
            delayRules = delayRules.addRule('ns','Delay (ns)',@(f) 1e-3*f, @(f) 1e3*f);
            delayRules = delayRules.addRule('us','Delay (\ms)',@(f) 1e-6*f, @(f) 1e6*f);

            %wavelengths
            wlRules = doubleWithUnits([],'nm','Wavelength (nm)');            
            wlRules = wlRules.addRule('um','Wavelength (\mm)',@(f) 1e3*f, @(f) 1e-3*f);
            wlRules = wlRules.addRule('eV','Energy (eV)',@(f) 1239.8./f, @(f) 1239.8./f);
            wlRules = wlRules.addRule('ecm-1','Wavenumber (cm^{-1})',@(f) 1e7./f, @(f) 1e7./f);
            
            % Assign unit rules to object data for each object array element, while keeping existing data
            obj.spectra = doubleWithUnits(obj.spectra.data,spectraRules);
            obj.spectra_std = doubleWithUnits(obj.spectra_std.data,spectraRules);
            obj.delays = doubleWithUnits(obj.delays.data,delayRules);
            obj.t0 = doubleWithUnits(obj.t0.data,delayRules);
            obj.wavelengths = doubleWithUnits(obj.wavelengths.data,wlRules); 
            
            %package unit rules to unitrules struct
            unitRules = struct('spectraRules',spectraRules,'delayRules',delayRules,'wlRules',wlRules);
        end
    end
    
    %% Protected methods (General class functionality)
    methods %(Access = protected)
        function [obj, unitStr, nameFlag] = buildDisplayNames(obj,varargin)
        % BUILDDISPLAYNAMES generates a generic name rule for data display and
        % export. The method updates the displayNames property. The default nameRule
        % order is shortName, label, dataUnit, scheme, gPos, repeats, wl, and delay.
        % Further modifications can be made by using the varargin flags or by directly
        % using nameRule class methods.
        %
        % [obj, unitStr, nameFlag] = BUILDDISPLAYNAMES(obj,varargin)
        %   Updates obj's displayName based on the data inside obj. Use varargin to
        %   override the display behavior for various name parts. varargin is a
        %   comma separated list of name-value pairs of type char-logical
        % 
        % Name-Value pairs:
        %   shortName: (logical) show the short name
        %   label: (logical) show function specific label
        %   scheme: (logical) show the scheme name
        %   gPos: (logical) show the grating position
        %   repeats: (logical) show the rpt number
        %   delays: (logical) show the delay number
        %   wavelengths: (logical) show the wavelength number
        %   spectraUnit: (logical) show the data unit
        %
        % See also: NAMERULE
        
        %1. set default naming options for exported data when there are multiple schemes and grating positions
            nameFlag = struct('shortName', length(unique({obj(:).shortName}))>1,...     %show the short name
                              'label', false,...                                        %show function specific label
                              'scheme', length(obj.getUniqueLabels('schemes'))>1,...              %show the scheme name
                              'gPos', false,...         %show the grating position
                              'repeats', false,...      %show the rpt number
                              'delay', false,...        %show the delay number
                              'wavelengths', false,...  %show the wavelength number
                              'spectraUnit', false);    %show the data unit
        
        
        %2. use parser object to override nameFlag values with user arguments 
            % and pass additional inputs
            p = inputParser;
            p.FunctionName = 'buildDisplayNames';
            
            %add nameFlag fields in loop so that partial matching can be used
            paramNames = fieldnames(nameFlag);
            for ii = 1:length(paramNames)
                p.addParameter(paramNames{ii}, nameFlag.(paramNames{ii}), @(l)islogical(l));
            end
            
            %parse arguments and collect results
            p.parse(varargin{:});
            for ii = 1:length(paramNames)
                nameFlag.(paramNames{ii}) = p.Results.(paramNames{ii});
            end
            
        %3. define unit strings for each object
            
            % Format object array dims into a column for easy looping
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            
            for objInd = 1:objNumel
                unitStr = struct('spectra',obj(objInd).spectra.unit,...
                                 'wl',obj(objInd).wavelengths.unit,...
                                 'delay',obj(objInd).delays.unit);

            %4. build name rule for each object. NOTE: this does not add wavelength or delay 
                %strings since these are grating position and can be repeatindex specific
                obj(objInd).displayNames = nameRule({...
                    'shortName',  {obj(objInd).shortName},                                                          0, nameFlag.shortName && ~isempty(obj(objInd).shortName);...
                    'label',      {''},                                                                             0, nameFlag.label;...
                    'dataUnit',   {['in ' unitStr.spectra]},                                                        0, nameFlag.spectraUnit;...
                    'scheme',     obj(objInd).schemes,                                                              1, nameFlag.scheme;...
                    'gPos',       strcat({'gPos: '},strcat(strtrim(cellstr(num2str(obj(objInd).gPos(:))))), ' nm'), 2, nameFlag.gPos;...
                    'repeats',    strcat({'rpt '}, strtrim(cellstr(num2str((1:obj(objInd).sizes.nRpts)')))),        3, nameFlag.repeats;...
                    'wl',         {''},                                                                             4, nameFlag.wavelengths;... 
                    'delay',      {''},                                                                             4, nameFlag.delay});

            %5. reset counter
                obj(objInd).displayNames = obj(objInd).displayNames.reset;
            end
            
            %convert object array back to original size
            obj = reshape(obj,objSize);
        
        end
    end
    
    %% Plotting/contour methods for data display
    methods
        function plotSpectra(obj, varargin)
        % PLOTSPECTRA plots the spectra contained inside the object. This method
        % attempts to automate formatting the plot by assigning appropriate legend
        % names to each spectra and by assigning axis labels. This method is a
        % wrapper for the plot function and allows for passing plot arguments. This
        % method also preservers axis hold behavior. 
        %
        % obj.PLOTSPECTRA()
        %   Plots all spectra contained in obj on the current axis, including all
        %   delays, grating positions, schemes, and objects if obj is an array.
        % 
        % obj.PLOTSPECTRA(varargin)
        %   Plots spectra with options specified by varargin, which is a comma
        %   separated list of name-value pairs.
        %
        % Name-value pairs:
        %   'delays': (double array) subset of delays to plot. The method finds the
        %       nearset delay inside the object.
        %   'index': (logical) if set to true, this option will plot the pixel's
        %       index, instead of current unit, on the x-axis
        %   'average': (logical) if set to false, this option will override the
        %       default behavior of averaging over all repeats
        %   'legend': (logical) if set to false, this option will override
        %       the default behavior of displaying the legend
        %
        % obj.PLOTSPECTRA(..., plotArg1, plotArg2,...)
        %   Plots spectra with additional arguments passed to plot, including line 
        %   properties specified by linespec.
        %
        % obj.PLOTSPECTRA(ax,...)
        %   Plots spectra on specified axis.
        %
        % See Also: PLOT, PLOTKINETICS

        %1. use parser object to override plotFlag values with user arguments and pass extra arguments to plot
            p = inputParser;
            p.FunctionName = 'plotSpectra';
            p.KeepUnmatched = true;
            
            %default values for flags
            plotFlag = struct('average',true,...
                               'legend',true);
            
            %allow user to specify axes object with plot
            p.addOptional('ax',gca,@(ax)isa(ax,'matlab.graphics.axis.Axes'));
                       
            %add plotFlag fields in loop so that partial matching can be used    
            paramNames = fieldnames(plotFlag);
            for ii = 1:length(paramNames)
                p.addParameter(paramNames{ii}, plotFlag.(paramNames{ii}), @(l)islogical(l));
            end
            
            %add delay list with all delays (empty array) as default value
            p.addParameter('delays',[], @(d) isa(d,'double') && isvector(d));
            
            %add an option to display the index on the x-axis
            p.addParameter('index',false, @(l) islogical(l));
            
            %User may also specify a linespec argument. inputParser is not
            %smart enough to parse linespec, therefore remove and parse
            %manually:
            linespec = '-';
            for ii = 1:length(varargin)
                if islinespec(varargin{ii}) %if the input is a linespec
                    linespec = varargin{ii}; %update linespec value
                    varargin(ii) = [];  %remove argument from varargin
                end
            end
            
            %parse arguments and collect results
            p.parse(varargin{:});
            
            %collect flag options
            for ii = 1:length(paramNames)
                plotFlag.(paramNames{ii}) = p.Results.(paramNames{ii});
            end
            
            %collect delay subset to plot
            delayVals = p.Results.delays;
            
            %collect extra arguments to pass to plot:
            extraArgs = struct2cell(p.Unmatched);
            
        %2. Object pre-formatting to ready data for plot loop
            % Format object array dims into a column for easy looping
            objNumel = numel(obj);
            obj = obj(:);
            
            %Ensure all objects in array have the same units
            tmpUnits = cell(3,1);
            [tmpUnits{:}] = obj(1).getUnits;
            obj = obj.setUnits(tmpUnits{:});
            
            %average object over repeats
            if plotFlag.average
                obj = obj.average;
            end
            
            %Generate object name rule for line/legend display
            [obj, unitStr] = obj.buildDisplayNames('shortName',true);
            
            %check hold state to preserve default axes class display behavior
            holdState = ishold();
            firstTime = true;
        
        %3. Loop over data, do object index specific formatting, and plot data
            for objInd = 1:objNumel  %loop over elements of object array
                
                %if user specified a delay subset, get object subset to plot
                if ~isempty(delayVals)
                    obj(objInd) = obj(objInd).subset('delays',delayVals);
                end
                
                %modify legend name rules for specific object element
                legendNames = obj(objInd).displayNames.modify(...
                    'gPos.flag',    obj(objInd).sizes.nGPos > 1,...     %if multiple grating positions
                    'repeats.flag', obj(objInd).sizes.nRpts > 1,...     %this will only display if average is off
                    'delay.flag',   obj(objInd).sizes.nDelays > 1,...   %display delays
                    'delay.values', strcat(strtrim(cellstr(num2str(mean(obj(objInd).delays.data,[2,3],'omitnan'),'%.3g'))), {' '}, unitStr.delay)); %delay values
                
                %adjust increment levels to match loop/permute/reshape
                %order:          pos loop, [spectra, rpts x delays x schemes]
                %significance:       1                 4       3        2
                legendNames = legendNames.modify(...
                    'gPos.level',1,...
                    'scheme.level',2,...
                    'repeats.level',4,...
                    'delay.level',3);
                
                %rearrange name display order to match significance order:
                legendNames = legendNames.rearrange('shortName','gPos','scheme','delay','repeats');
                
                %build legend name levels for autoincrementing name across loop
                legendNames = legendNames.buildLevels();
                
                %loop over grating positions
                for ii = 1:obj(objInd).sizes.nGPos  
                    %add data to x
                    x = obj(objInd).wavelengths.data(:,ii);
                    
                    %if user specified 'index', true option
                    if p.Results.index
                        x = 1:length(x);
                    end
                    
                    %avg of rpts and pick the first dataScheme
                    y = obj(objInd).spectra.data(:,:,:,ii,:); %[pixels, delays, rpts, grating pos, schemes]
                    y = permute(y,[1,3,2,5,4]); %change display priority [pixels, rpts, delays, schemes,1]
                    y = reshape(y,obj(objInd).sizes.nPixels,[]); %[pixels, rpts x delays x schemes x 1]
                    
                    %Loop over columns of y-data to assign a display name for each line
                    for jj = 1:size(y,2)
                        if ~all(isnan(y(:,jj))) %make sure there are values to plot
                            %generate legend name
                            [plotDispStr, legendNames] = legendNames.buildName('autoIncrement',true,'delimiter',', ');

                            %custom generate inputs to pass to plot function
                            plotArgs = [{p.Results.ax}; {x; y(:,jj)}; {linespec}; extraArgs{:}; {'DisplayName'}; {plotDispStr}];  

                            %This preserves the default axes class display behavior
                            if firstTime
                                plot(plotArgs{:});
                                firstTime = false;
                                hold on;
                            else
                                plot(plotArgs{:});
                            end
                        else %if the spectra is all NaN
                            %skip plotting in increment legend name
                            legendNames = legendNames.increment;
                        end
                        
                    end %loop over delays x schemes
                end %loop over grating positions
            end %loop over object elements
        
        %4. Post-formatting
            %return to previous hold state
            if ~holdState
                hold off;
            end
            
            %display legend for all lines
            if plotFlag.legend
                legend();
            end
            
            %update x and y units
            ylabel(obj(1).spectra.dispName);
            
            %if user specified 'index', true option
            if p.Results.index
                xlabel('index'); 
            else %normal x-axis label display
                xlabel(obj(1).wavelengths.dispName);
            end
        end
        
        function plotKinetics(obj, varargin)
        % PLOTKINETICS plots kinetic traces contained inside the object. This method
        % attempts to automate formatting the plot by assigning appropriate legend
        % names to each trace and by assigning axis labels. This method is a
        % wrapper for the plot function and allows for passing plot arguments. This
        % method also preservers axis hold behavior. 
        %
        % obj.PLOTKINETICS()
        %   Plots all kinetic traces contained in obj on the current axis, including
        %   all pixels, grating positions, schemes, and objects if obj is an array.
        % 
        % obj.PLOTKINETICS(varargin)
        %   Plots kinetic traces with options specified by varargin, which is a comma
        %   separated list of name-value pairs.
        %
        % Name-value pairs:
        %   'wavelengths': (double array) subset of wavelengths to plot. The method 
        %       finds the nearset wavelength inside the object.
        %   'index': (logical) if set to true, this option will plot the delay's
        %       index, instead of current unit, on the x-axis
        %   'average': (logical) if set to false, this option will override the
        %       default behavior of averaging over all repeats
        %   'legend': (logical) if set to false, this option will override
        %       the default behavior of displaying the legend
        %
        % obj.PLOTKINETICS(..., plotArg1, plotArg2,...)
        %   Plots kinetic traces with additional arguments passed to plot, including
        %   line properties specified by linespec.
        %
        % obj.PLOTKINETICS(ax,...)
        %   Plots kinetic traces on specified axis.
        %
        % See Also: PLOT, PLOTSPECTRA
            
        %1. use parser object to override plotFlag values with user arguments and pass extra arguments to plot
            p = inputParser;
            p.FunctionName = 'plotKinetics';
            p.KeepUnmatched = true;
            
            %allow user to specify axes object with plot
            p.addOptional('ax',gca,@(ax)isa(ax,'matlab.graphics.axis.Axes'));
            
            %default values for flags
            plotFlag = struct('average',true,... %add an option to average data before plotting
                               'legend',true,... %add an option to display the legend
                               'index',false);   %add an option to display the index on the x-axis
            
            %add plotFlag fields in loop so that partial matching can be used
            paramNames = fieldnames(plotFlag);
            for ii = 1:length(paramNames)
                p.addParameter(paramNames{ii}, plotFlag.(paramNames{ii}), @(l)islogical(l));
            end
            
            %add delay list with all delays (empty array) as default value
            p.addParameter('wavelengths',[], @(d) isa(d,'double') && isvector(d));
            

            
            %User may also specify a linespec argument. inputParser is not
            %smart enough to parse linespec, therefore remove and parse
            %manually:
            linespec = '-';
            for ii = 1:length(varargin)
                if islinespec(varargin{ii}) %if the input is a linespec
                    linespec = varargin{ii}; %update linespec value
                    varargin(ii) = [];  %remove argument from varargin
                end
            end
            
            %parse arguments and collect results
            p.parse(varargin{:});
            
            %collect flag options
            for ii = 1:length(paramNames)
                plotFlag.(paramNames{ii}) = p.Results.(paramNames{ii});
            end
            
            %collect delay subset to plot
            wlVals = p.Results.wavelengths;
            
            %collect extra arguments to pass to plot:
            extraArgs = struct2cell(p.Unmatched);
            
        %2. Object pre-formatting to ready data for plot loop
            % Format object array dims into a column for easy looping
            objNumel = numel(obj);
            obj = obj(:);
            
            %Ensure all objects in array have the same units
            tmpUnits = cell(3,1);
            [tmpUnits{:}] = obj(1).getUnits;
            obj = obj.setUnits(tmpUnits{:});
            
            %average object over repeats
            if plotFlag.average
                obj = obj.average;
            end
            
            %Generate object name rule for line/legend display
            [obj, unitStr] = obj.buildDisplayNames();
            
            %check hold state to preserve default axes class display behavior
            holdState = ishold();
            firstTime = true;
        
        %3. Loop over data, do object index specific formatting, and plot data
            for objInd = 1:objNumel  %loop over elements of object array
                
                %if user specified a delay subset, get object subset to plot
                if ~isempty(wlVals)
                    obj(objInd) = obj(objInd).subset('wavelengths',wlVals);
                end
                
                %modify legend name rules for specific object element
                legendNames = obj(objInd).displayNames.modify(...
                    'gPos.flag',    obj(objInd).sizes.nGPos > 1,...     %if multiple grating positions
                    'repeats.flag', obj(objInd).sizes.nRpts > 1,...     %this will only display if average is off
                    'wl.flag',   obj(objInd).sizes.nDelays > 1,...      %display delays
                    'wl.values', repmat({''},obj(objInd).sizes.nPixels)); %delay values
                
                %adjust increment levels to match loop/permute/reshape
                %order:          pos loop, [spectra, rpts x wls x schemes]
                %significance:       1                 4     3       2
                legendNames = legendNames.modify(...
                    'gPos.level',1,...
                    'scheme.level',2,...
                    'repeats.level',4,...
                    'wl.level',3);
                
                %rearrange name display order to match significance order:
                legendNames = legendNames.rearrange('shortName','gPos','scheme','wl','repeats');
                
                %build legend name levels for autoincrementing name across loop
                legendNames = legendNames.buildLevels();
                
                %loop over grating positions
                for ii = 1:obj(objInd).sizes.nGPos  
                    %add data to x, y to plot
                    x = mean(obj(objInd).delays.data(:,:,ii),2);
                    
                    %if user specified 'index', true option
                    if p.Results.index
                        x = 1:length(x);
                    end
                    
                    %avg of rpts and pick the first dataScheme
                    y = obj(objInd).spectra.data(:,:,:,ii,:); %[pixels, delays, rpts, grating pos, schemes]
                    y = permute(y,[2,3,1,5,4]); %change display priority [delays, rpts, pixels, schemes,1]
                    y = reshape(y,obj(objInd).sizes.nDelays,[]); %[delays, rpts x pixels x schemes x 1]
                    
                    %update wavelength values specific to the grating position
                    legendNames = legendNames.modify(...
                        'wl.values', strcat(strtrim(cellstr(num2str(obj(objInd).wavelengths(:,ii),'%.4g'))), {' '}, unitStr.wl));
                    
                    %Loop over columns of y-data to assign a display name for each line
                    for jj = 1:size(y,2)
                        %check if y-data exists (is not all NaN)
                        if ~all(isnan(y(:,jj)))
                            %generate legend name
                            [plotDispStr, legendNames] = legendNames.buildName('autoIncrement',true,'delimiter',', ');

                            %custom generate inputs to pass to plot function
                            plotArgs = [{p.Results.ax}; {x; y(:,jj)}; {linespec}; extraArgs{:}; {'DisplayName'}; {plotDispStr}];   

                            %This preserves the default axes class display behavior
                            if firstTime
                                plot(plotArgs{:});
                                firstTime = false;
                                hold on;
                            else
                                plot(plotArgs{:});
                            end
                        else
                            %This grating position does not contain the specified wavelength. 
                            %Skip this line and increment name rule
                            legendNames = legendNames.increment;
                        end
                        
                    end %loop over delays x schemes
                end %loop over grating positions
            end %loop over object elements
        
        %4. Post-formatting
            %return to previous hold state
            if ~holdState
                hold off;
            end
            
            %display legend for all lines
            if plotFlag.legend
                legend();
            end
            
            %update x and y units
            ylabel(obj(1).spectra.dispName);
            
            %if user specified 'index', true option
            if p.Results.index
                xlabel('index'); 
            else %normal x-axis label display
                xlabel(obj(1).delays.dispName);
            end
        end
    end
    
    %% Data manipulation methods that modify the spectra object
    methods
        
        function mergedObj = merge(obj, varargin)
% MERGE together objects in an object array into one object. 
% Use this method when you have seperate files or objects that you want to 
% combine over grating positions, repeats, schemes, or delays. This method
% asserts that the spectra sizes and dim labels match before merging.
% Additional object metadata is kept only for the 1st object element across
% the merge dimension.
%
% mergedObj = obj.merge(mergeMethod);
%   Merges all elements of obj (obj array) across the dim specified by
%   mergeMethod. mergeMethod is a char array name of the spectra dimension,
%   such as 'rpt'. See below for a list and description of implemented
%   mergeMethods.
%
% mergedObj = obj.merge(__, 'dim', dimVal);
%   Merges multidimentional object array obj across its dimVal dimension.
%
% Implemented mergeMethod keywords:
%   'rpts' Merges the elements of the object array by treating them as
%       different repeats. This creates a new object whose repeats are
%       appended together. Merging across rpts is also grating position
%       aware, meaning repeats are appended to their corresponding grating 
%       position. Appending repeats does not ensure  grating positions are
%       matched, e.g. if obj elem 1 has 2 rpts with a gPos = 460, and
%       elem 2 has 2 rpts with gPos = 630, the merged objects will have 2
%       gPos and 4 rpts. Note that unmatched grating positions can cause
%       unexpected behavior when stitching and followed by averaging. It is
%       recommended that you average before stitching. If you need the 
%       grating positions to be matched, use the 'gPos' merge method. 
%       Finally, all merged objects must have the same number of pixels, 
%       delays, and the same schemes.
%
%   'gPos' Merges the elements of the object array by treating them as
%       different grating positions. This creates a new object composed of
%       the object element grating positions. This method matches repeats
%       across grating positions by ordering them consecutively, e.g. if
%       obj elem 1 has 2 rpts and obj elem 2 has 3 rpts, the first two rpts
%       will be treated as the same repeat but different grating position,
%       and the 3rd repeat of obj 2 will remain unmatched. This mergeMethod
%       requires that each object element contains a unique set of grating 
%       positions. If you need to merge objects with overlapping grating 
%       positions, use the 'rpts' mergeMethod instead. Finally, all merged
%       objects must have the same number of pixels, delays, and the same
%       schemes.
%
% See Also: SPLITSCHEMES

            p = inputParser;
            p.addRequired('mergeDim');      % the object dim to merge over, e.g. repeats
            p.addParameter('dim','all');    % the object array dim to merge over
            
            p.parse(varargin{:});
            
            % Reshape object so that merged dim is 1st
            if ischar(p.Results.dim) % merge together all dims as one
                obj = obj(:);
                dimOrdr = [1, 2]; %internal dim permute order
                objSize = [1, 1]; %internal object size
            else % merge specific dim
                % determine internal dim permute order
                dimOrdr = 1:numel(size(obj));
                dimOrdr(p.Results.dim) = [];
                dimOrdr = [p.Results.dim dimOrdr];
                
                % determine internal object size
                objSize = [1 sizePadded(obj,dimOrdr(2:end))];
                
                % move merge dim to front and flatten the remaining dims
                obj = permute(obj,dimOrdr);
                obj = reshape(obj,[],prod(objSize));
            end
            
            % The output merge object will be built off of the 1st object element along the merge dim
            mergedObj = obj(1,:);
            
            % The number of object elements to merge and loop over
            mergeNumel = size(obj,1);
            extraDims = size(obj,2);
            
            % Set object units to match 1st objects units in the merge set
            tmpUnits = cell(3,1);
            for mergeInd = 1:mergeNumel
                [tmpUnits{:}] = obj(mergeInd,1).getUnits();
                obj(mergeInd,:) = obj(mergeInd,:).setUnits(tmpUnits{:});
            end
                
            % Loop over extra non-merge dims
            for objInd = 1:extraDims
                % Gather sizes of all dims
                sizeFields = fieldnames(obj(1,objInd).sizes);   %size field names
                spectraSizes = zeros(mergeNumel,numel(sizeFields));  %spectra size array [nMergeObj,nSpectraDims]
                
                % Define the dims indicies (logical array) for various sizes
                pixelDim = strcmp(sizeFields,'nPixels');
                delayDim = strcmp(sizeFields,'nDelays');
                gPosDim = strcmp(sizeFields,'nGPos');
                rptDim = strcmp(sizeFields,'nRpts');
                schemeDim = strcmp(sizeFields,'nSchemes');
                
                % Fill size double array
                for mergeInd = 1:mergeNumel
                    spectraSizes(mergeInd,:) = cell2mat(struct2cell(obj(mergeInd,objInd).sizes))'; %[nObj,nSpectraDims]
                end
                
                % Gather the various grating positions in the data sets
                % gPosInds: [max number of gPos in any object element, nUniquegPos, nMergeObj]
                [uniqueGPos, gPosInds] = obj(:,objInd).getUniqueLabels('gPos'); 
                
                % Gather the various schemes in the data sets
                % schemeInds: [max number of schemes in any object element, nUniqueSchemes, nMergeObj]
                [uniqueSchemes, schemeInds] = obj(:,objInd).getUniqueLabels('schemes'); 
                
                % Merge implementations. Add any new implementations here!
                switch p.Results.mergeDim
                    case 'rpts'
                        % Merging over rpts needs to to check that the number of wavelengths and delays
                        % are the same and that the schemes are the same. 
                        % The merge does not check that the wavelength or delay values are the same
                        % If there is a mismatch in grating positions, the extra values are set to NaN

                        % Assert that the number of pixels and delays is the same
                        rInd = any([delayDim(:),pixelDim(:)],2);
                        assert(all(spectraSizes(:,rInd)==spectraSizes(1,rInd),'all'),...
                            'Merging of rpts requires that all merge objects have the same number of wavelengths and delays. ',...
                            'Use obj.interp() to enforce this condition.');

                        % Assert that the schemes are the same
                        assert(all(schemeInds==schemeInds(:,:,1),'all'),...
                            'The schemes in the object array do not match. ',...
                            'Use obj.splitSchemes() and obj.merge() to ensure that all objects have the same schemes and in the same order');

                        % calculate the sizes of the new data
                        sz = spectraSizes(1,:); %[nObj,nSpectraDims]
                        sz(gPosDim) = numel(uniqueGPos);
                        sz(rptDim) = sum(spectraSizes(:,rptDim));

                        % permute sz and create new spectra, delay, and pixel holder arrays
                        % set spectra and delays to NaN so that they can be filled in by the loop below
                        sz = sz([find(pixelDim),find(delayDim),find(rptDim),find(gPosDim),find(schemeDim)]);
                        s = nan(sz); %[pixels, delays, rpts, grating pos, schemes]
                        l = nan(sz([1,3,4]));   %[pixels, repeats, grating pos]
                        t = nan(sz([2,3,4])); %[delays, repeats, grating pos]

                        % fill in delays and spectra by object index
                        rptInd = 0;
                        for mergeInd = 1:mergeNumel
                            % calculate the number of repeats and indicies of the grating positions
                            nRpts = spectraSizes(mergeInd,rptDim);
                            [~,gPOrder] = find((obj(mergeInd,objInd).gPos(:)) == uniqueGPos(:)');

                            % copy data from object element in holder arrays
                            s(:,:,rptInd + (1:nRpts),gPOrder,:) = obj(mergeInd,objInd).spectra.data;
                            l(:,rptInd + (1:nRpts),gPOrder) = repmat(permute(obj(mergeInd,objInd).wavelengths.data,[1,3,2]),1,nRpts,1);
                            t(:,rptInd + (1:nRpts),gPOrder) = obj(mergeInd,objInd).delays.data;

                            % update repeat counter
                            rptInd = rptInd + nRpts;
                        end

                        %copy holder arrays into object member data
                        mergedObj(objInd).spectra.data = s;
                        mergedObj(objInd).wavelengths.data = permute(mean(l,2,'omitnan'),[1,3,2]);
                        mergedObj(objInd).delays.data = t;

                        %Update sizes and grating positions
                        mergedObj(objInd).sizes.nRpts = sz(3);
                        mergedObj(objInd).sizes.nGPos = sz(4);
                        mergedObj(objInd).gPos = uniqueGPos;
                        
                    case 'gPos'
                        % Merging over gPos needs to to check that the number of wavelengths and delays
                        % are the same and that the schemes are the same. 
                        % The merge does not check that the wavelength or delay values are the same
                        % If there is a mismatch in grating positions, the extra values are set to NaN

                        % Assert that the number of pixels and delays is the same
                        rInd = any([delayDim(:),pixelDim(:)],2);
                        assert(all(spectraSizes(:,rInd)==spectraSizes(1,rInd),'all'),...
                            ['Merging of rpts requires that all merge objects have the same number of wavelengths and delays. ',...
                            'Use obj.interp() to enforce this condition.']);
                        
                        % Assert that each object element contains a unique set of grating positions
                        % by checking that each unique gPos has only one index
                        %[max number of gPos in any object element, nUniquegPos, nMergeObj]
                        assert(all(sum(gPosInds,[1,3])==1,'all'),...
                            ['Merging of gPos requires that each merge object element has a unique set of grating positions. ',...
                            'Use obj.merge(''rpts'') if you need to merge object elements with overlaping grating positions.']);
                        
                        % Assert that the schemes are the same
                        assert(all(schemeInds==schemeInds(:,:,1),'all'),...
                            ['The schemes in the object array do not match. ',...
                            'Use obj.splitSchemes() and obj.merge() to ensure that all objects have the same schemes and in the same order']);

                        % calculate the sizes of the new data
                        sz = spectraSizes(1,:); %[nObj,nSpectraDims]
                        sz(gPosDim) = numel(uniqueGPos);
                        sz(rptDim) = max(spectraSizes(:,rptDim));
                        
                        % permute sz and create new spectra, delay, and pixel holder arrays
                        % set spectra and delays to NaN so that they can be filled in by the loop below
                        sz = sz([find(pixelDim),find(delayDim),find(rptDim),find(gPosDim),find(schemeDim)]);
                        s = nan(sz); %[pixels, delays, rpts, grating pos, schemes]
                        l = nan(sz([1,3,4]));   %[pixels, repeats, grating pos]
                        t = nan(sz([2,3,4])); %[delays, repeats, grating pos]
                        
                        % fill in delays and spectra by object index
                        for mergeInd = 1:mergeNumel
                            % calculate the number of repeats and indicies of the grating positions
                            nRpts = spectraSizes(mergeInd,rptDim);
                            [~,gPOrder] = find((obj(mergeInd,objInd).gPos(:)) == uniqueGPos(:)');

                            % copy data from object element in holder arrays
                            s(:,:,1:nRpts,gPOrder,:) = obj(mergeInd,objInd).spectra.data;
                            l(:,1:nRpts,gPOrder) = repmat(permute(obj(mergeInd,objInd).wavelengths.data,[1,3,2]),1,nRpts,1);
                            t(:,1:nRpts,gPOrder) = obj(mergeInd,objInd).delays.data;
                        end

                        %copy holder arrays into object member data
                        mergedObj(objInd).spectra.data = s;
                        mergedObj(objInd).wavelengths.data = permute(mean(l,2,'omitnan'),[1,3,2]);
                        mergedObj(objInd).delays.data = t;

                        %Update sizes and grating positions
                        mergedObj(objInd).sizes.nRpts = sz(3);
                        mergedObj(objInd).sizes.nGPos = sz(4);
                        mergedObj(objInd).gPos = uniqueGPos;
                        
                end  %end case
            end
            
            % convert object back to original size
            mergedObj = reshape(mergedObj,objSize);
            [~,ordrInd] = sort(dimOrdr);
            mergedObj = permute(mergedObj,ordrInd);
            
            
        end
        
        function obj = average(obj, varargin)
        % AVERAGE all repeats, wavelengths, and/or delays for each element in 
        % the object array. 
        %
        % Note that this method treats various dims in the spectra array as having 
        % the same nominal delay and wavelength values (unless it is a different 
        % grating position). Therefore, the output delay and wavelength will be 
        % averaged accordingly. Call obj.interp before calling obj.average if you 
        % wish to correct for small differences in delay or wavelength accross 
        % repeats.
        %
        % obj = obj.AVERAGE()
        %	Averages all repeats for obj.spectra, obj.spectra_std, obj.delays and
        %	updates obj.sizes
        %
        % obj = obj.AVERAGE('delays')
        %	Averages all delays for obj.spectra, obj.spectra_std, obj.delays and
        %	updates obj.sizes
        %
        % obj = obj.AVERAGE('wavelengths')
        %	Averages all wavelengths for obj.spectra, obj.spectra_std, obj.delays 
        %   and	updates obj.sizes. When multiple grating positions are present,
        %	the grating positions are averaged individually.
        %
        % obj = obj.AVERAGE('rpts','delays')
        %	Averages all repeats and delays for obj.spectra, obj.spectra_std, 
        %	obj.delays and updates obj.sizes 
        %
        % See Also: MEAN, INTERP
            
            % Format object array dims into a column for easy looping
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            
            if isempty(varargin)
                varargin{1} = 'rpts';
            end
            
            for objInd = 1:objNumel
                for ii = 1:length(varargin)
                    switch varargin{ii}
                        case 'rpts'
                            %average over repeats in data
                            obj(objInd).spectra.data = mean(obj(objInd).spectra.data,3,'omitnan');
                            obj(objInd).spectra_std.data = sqrt(mean(obj(objInd).spectra_std.data.^2,3,'omitnan'));
                            obj(objInd).delays.data = mean(obj(objInd).delays.data,2,'omitnan');
                            %todo: add delay uncertainty?

                            %update sizes
                            obj(objInd).sizes.nRpts = 1;
                            
                        case 'delays'
                            %average over repeats in data
                            obj(objInd).spectra.data = mean(obj(objInd).spectra.data,2,'omitnan');
                            obj(objInd).spectra_std.data = sqrt(mean(obj(objInd).spectra_std.data.^2,2,'omitnan'));
                            obj(objInd).delays.data = mean(obj(objInd).delays.data,1,'omitnan');
                            %todo: add delay uncertainty?

                            %update sizes
                            obj(objInd).sizes.nDelays = 1;
                        
                        case 'wavelengths'
                            obj(objInd).spectra.data = mean(obj(objInd).spectra.data,1,'omitnan');
                            obj(objInd).spectra_std.data = sqrt(mean(obj(objInd).spectra_std.data.^2,1,'omitnan'));
                            obj(objInd).wavelengths.data = mean(obj(objInd).wavelengths.data,1,'omitnan');
                            
                        otherwise
                            error([varargin{ii} ' is not a valid dimension to average over.']);
                    end
                       
                end
            end
            
            %convert object array back to original size
            obj = reshape(obj,objSize);
        end
        
        function obj = stitch(obj,varargin)
        % STITCH together available grating positions in object array for each elem. 
        % This works by sorting the data in ascending wavelength and stitching a 
        % pair of grating positions at a time. For multiple grating positions, 
        % the previously stitched grating position is treated as the first grating 
        % position in the stich pair. The stitching behavior in any overlap region 
        % can be done with the following strageiges: average, lower, upper, half, 
        % and linear. Stitching preserves all other dimensions, such as repeats and
        % delays. Stitching currently updates all relevant properties such as 
        % wavelengths, spectra, and grating positions.
        %
        % Notes: 
        % 1. Be careful when combining stitching and interpolation. Interpolation 
        %   before stitching with extrapolation may cause unexpected behavior. This
        %   occurs because interpolation does not distinguish between gratings. 
        %   Extrapolation beyond the grating wavelength range will set those values
        %   to unrealistic non-NaN values. Stitching uses NaN as a flag that 
        %   wavelength data is missing. When extrapolation is required, stitch 
        %   before performing interpolation.
        % 2. If data points are missing (set to NaN) in the overlap region for a 
        %   particular grating position pair, the overlap region in the stitched
        %   data point will be set to NaN. In these cases, the method returns a
        %   warning and recommends calling average() before stitch().
        %
        % todo: update spectra_std. 
        % todo: may need to create a case for direct stitching
        %
        % obj = obj.STITCH()
        %   Stitches all grating positions using the default strategy of linear.
        %   Updates obj.spectra, obj.delays, obj.wavelengths, and obj.sizes
        %
        % obj = obj.STITCH(strategy)
        %   Same as the obj.stitch call but with specified strategy that deterimnes
        %   how to handle data in the grating position overlap region. The strategy
        %   input is type char array. The default is 'linear'
        %
        % The following strategies for handling overlap regions are supported:
        %   'lower': overlap region will be data from the lower grating position
        %   'upper': overlap region will be data from the upper grating position
        %   'average': overlap region will be an average of the lower and upper
        %       grating position.
        %   'half': the lower half of the overlap region will be from the lower
        %       grating position and the upper half of the overlap region will be
        %       from the upper grating position.
        %   'linear': overlap region will be a weighted average of the lower and
        %       upper grating position, where the weights linearly change from 100%
        %       lower on the lower end of the overlap region to 100% upper on the
        %       upper end of the overlap region. The weights are 50%:50% in the
        %       middle of the overlap region.
        %
        % See Also: AVERAGE, INTERP, MERGE
            
            %optional inputs: strategy for stitching. Default is linear
            p = inputParser();
            p.addOptional('strategy','linear',@(s) ischar(s) && any(strcmp(s,{'average','lower','upper','half','linear'})));
            p.parse(varargin{:});
                        
            % Format object array dims into a column for easy looping
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            
            for objInd = 1:objNumel
                % use this to warn user that NaN values were encountered and data stitching may not be complete
                isDataComplete = true;
                
            %%--Revert units to nm--%%
                %remember old units
                tmpUnits = cell(3,1);
                [tmpUnits{:}] = obj(objInd).getUnits();

                %update units to units where x-axis is in nm
                obj(objInd) = obj(objInd).setUnits('nm',[],[]);       
                
            %%--Sort wavelengths and grating positions--%%
                %sort everything by ascending order in terms of grating position nm, wavelength nm, delay ps
                [gPosSorted,gInd] = sort(obj(objInd).gPos);
                [wl, lInd] = sort(obj(objInd).wavelengths.data(:,gInd));    %[wavelengths, grating positions]

                %sort by grating position first
                data = obj(objInd).spectra.data(:,:,:,gInd,:);  %[pixels, delays, rpts, GRATING POS, schemes]

                %sort by wavelengths next
                for ii = 1:size(lInd,2) %loop over grating positions
                    data(:,:,:,ii,:) = data(lInd(:,ii),:,:,ii,:); %[PIXELS, delays, rpts, GRATING POS, schemes]
                end
                
                %permute and reshape data so that it is easier to interpolate and stitch
                data = permute(data,[1,2,3,5,4]);   %[pixels, delays, rpts, schemes, grating pos]
                data = reshape(data,obj(objInd).sizes.nPixels,[],obj(objInd).sizes.nGPos); %[pixels, delays*rpts*schemes, grating pos]
                
            %%--Stitch wavelengths and data--%%
                %grating positions will be stitched in pairs sequentially. If there are multiple grating positions,
                %already stitched data will be treated as one grating position
                wlnan = all(isnan(data),2);  %determine which wavelengths are flagged as nan for all rpts, delays, etc. (usually caused by running interp)
                dropGPos = all(wlnan,1);  %determine which grating positions are all nan for removing them from data (rare, but otherwise crashes the method)
                wl = wl(:,~dropGPos); %drop any grating positions that are all nan
                data = data(:,:,~dropGPos); %drop any grating positions that are all nan
                
                tmpWl = wl(~wlnan(:,1),1);    %holder for concatonated wavelengths starting from 1st grating pos
                tmpData1 = data(~wlnan(:,1),:,1);  %holder for concatonated data starting from 1st grating pos
                
                if size(wl,2) > 1
                    for ii = 2:size(wl,2) %loop over grating positions starting from the 2nd one
                        %remove NaN from next grating position
                        tmpW2 = wl(~wlnan(:,ii),ii); 
                        tmpData2 = data(~wlnan(:,ii),:,ii);

                        %First find overlap region in wavelengths
                        high1 = tmpWl(end);    %highest wavelength in 1st grating position
                        low2 = tmpW2(1);     %lowest wavelength in 2nd grating position

                        [low1, low1Ind] = nearestVal(tmpWl,low2); %lowest wavelength and index in 1st grating position
                        [high2, high2Ind] = nearestVal(tmpW2,high1); %lowest wavelength and index in 2nd grating position

                        %Make sure indicies do not cause data/wavelength extrapolation (overlap region needs to be inclusive)
                        if low1<low2   %check first grating position
                            low1Ind = low1Ind + 1;
                            low1 = tmpWl(low1Ind);
                        end

                        if high2>high1 %check second grating position
                            high2Ind = high2Ind - 1;
                            high2 = wl(high2Ind,ii);
                        end

                        %define lower and upper regions
                        lowWl = tmpWl(1:low1Ind-1); %1st grating positions lower wavelengths
                        highWl = tmpW2(high2Ind+1:end); %2nd grating positions higher wavelengths
                        lowData = tmpData1(1:low1Ind-1,:);   %1st grating positions lower data
                        highData = tmpData2(high2Ind+1:end,:);   %second grating positoins higher data

                        %Next interpolate middle region
                        nInd = ceil(0.5*(length(tmpWl(low1Ind:end))+length(tmpW2(1:high2Ind))));    %average number of in-between indicies
                        midWl = linspace(low1,high2,nInd)';  %new wavelengths in overlap region with linear spacing between them
                        mid1Data = interp1(tmpWl,tmpData1,midWl,'linear');   %interpolate 1st grating position on overlap scale
                        mid2Data = interp1(tmpW2,tmpData2,midWl,'linear'); %interpolate 2nd grating position on overlap scale
                        
                        %Set warning flag to let user know that NaN values were encountered and stitching may be incomplete
                        if any(isnan(mid1Data), 'all') || any(isnan(mid2Data), 'all')
                            isDataComplete = false;
                        end
                        
                        %Execute strategy to combine data in overlap region
                        switch p.Results.strategy
                            case 'average' %take the average in the overlap region
                                midData = 0.5*(mid1Data+mid2Data);  
                            case 'lower' %take the lower (1st) grating position
                                midData = mid1Data;  
                            case 'upper' %take the higher (2nd) grating position
                                midData = mid2Data;  
                            case 'half'  %stitch at half-way point
                                midData = [mid1Data(1:floor(nInd/2),:); mid2Data((floor(nInd/2)+1):end,:)];
                            case 'linear'   %do a weighted average with a linear sweep of the weights from the 1st to 2nd grating position
                                weightsFun = polyfit([midWl(1), midWl(end)],[0, 1],1);    %linear fit for weights
                                weights = polyval(weightsFun,midWl);    %calculate weights from nm values
                                midData = mid1Data.*(1-weights)+mid2Data.*weights;  %this does the weighted average
                        end

                        %concatonate the three regions across the 1st (pixel) dimension
                        tmpWl = [lowWl; midWl; highWl]; %store in tmpWl so that it can be fed as 1st grating position in next iteration 
                        tmpData1 = [lowData; midData; highData]; %store in tmpdata so that it can be fed as 1st grating position in next iteration 
                    end
                end

            %%--Convert wavelengths and data back to original state and update object parameters--%%
                %reshape and permute data back to original dim order
                data = reshape(tmpData1,[],obj(objInd).sizes.nDelays,obj(objInd).sizes.nRpts,obj(objInd).sizes.nSchemes); %[pixels, delays, rpts, schemes, grating pos]
                data = permute(data,[1,2,3,5,4]); %[pixels, delays, rpts, grating pos, schemes]

                %update values for object properties
                obj(objInd).spectra.data = data;
                obj(objInd).wavelengths.data = tmpWl;
                obj(objInd).gPos = median(gPosSorted);
                obj(objInd).sizes.nPixels = length(tmpWl);
                obj(objInd).sizes.nGPos = 1;
                obj(objInd).delays.data = mean(obj(objInd).delays.data,3);
                
                %set units back to input units
                obj(objInd) = obj(objInd).setUnits(tmpUnits{:});
                
                %warn user that incomplete data was encountered
                if ~isDataComplete
                    warning(['Could not handle NaN values encountered while stitching the overlap region for object element %d. ',...
                             'The overlap region for these data points was set to NaN. ',...
                             'Calling average() before stitch() usually averages out unhandleable NaN data.'],objInd);
                end
            end
            
            %set 
            obj = reshape(obj, objSize);
        end
        
        function obj = trim(obj, varargin)
        % TRIM the specra wavelengths and/or delays to the specified range.
        % This function keeps data within the specified range and replaces data
        % outside the specified ranges with NaN. If all wavelengths or delays are
        % removed for the rpt, gpos, or scheme dimension, then the sizes of the
        % wavelength or delay dimensions are reduced to remove extra NaN values.
        % The trim ranges are specified by 'wavelengths',[lower,upper] or 
        % 'delays, [lower, upper]. By default, 'w' and 'delays' are set to 'all', 
        % which does not trim the dimensions.
        % 
        % obj = obj.TRIM()
        %   This call does nothing because the default values for 'wavelengths' and
        %   'delays' is 'all'.
        %
        % obj = obj.TRIM('wavelengths',[lowerWl,upperWl])
        %   Trims the wavelengths to be between lowerWl and upperWl for all grating
        %   positions, repeats, delays, and schemes. With multiple grating
        %   positions, trimmed data is replaced with NaN. Data size is adjsuted to
        %   remove extra NaN values.
        %
        % obj = obj.TRIM('delays',[lowerDelay,upperDelay])
        %   Trims the delays to be between lowerWl and upperWl. Delays are assumed
        %   to be nominally the same for all repeats, grating positions, and
        %   schemes. Trimmed data is replaced with NaN, but usually the data size
        %   is adjusted to remove the extra NaN values.
        % 
        % obj = obj.TRIM('wavelengths',[lowerWl,upperWl],...
        %                'delays',[lowerDelay,upperDelay])
        % obj = obj.TRIM('delays',[lowerDelay,upperDelay],...
        %                'wavelengths',[lowerWl,upperWl])
        %   Trims both wavelengths and delays as described above.
        %
        % See Also: SUBSET
            
            %define default values
            trimVals = struct('wls','all',...
                          'delays','all');
            
            %parse varargin
            if nargin > 1
                for ii = 1:2:(nargin-1)
                    assert(ischar(varargin{ii}),...
                        ['Invalid argument class for name-value pair. Expected class char for name, got ' class(varargin{ii}) '.']);
                    switch varargin{ii}
                        case 'wavelengths'
                            trimVals.wls = varargin{ii+1};
                        case 'delays'
                            trimVals.delays = varargin{ii+1};
                        otherwise
                            error([varargin{ii} ' is not a valid argument name.']); 
                    end
                end
            end
            
            % Format object array dims into a column for easy looping
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            
            for objInd = 1:objNumel
            
                %trim wavelengths
                if ischar(trimVals.wls)  %this is a do nothing case
                    % Assert correct input to ensure user isn't accidently doing something they're not aware of
                    assert(strcmp(trimVals.wls,'all'),'Expected all keyword or wavelength range [wl1, wl2] of type double.');

                elseif isa(trimVals.wls,'double')   %this does the wavelength trim
                    %ensure the user has correct input before trimming
                    assert(length(trimVals.wls)==2, 'Expected wavelength range [wl1, wl2] of type double.');
                    trimVals.wls = sort(trimVals.wls);  %ensure wavelengths are in increasing order

                    %find the wavelength range indicies in all grating positions
                    wls = obj(objInd).wavelengths.data(:);  %[pixels x gPos]
                    wls = wls(~isnan(wls));
                    wls = sort(wls);

                    %select t subrange within (inclusive) the trim range
                    wls = wls(and(wls>=trimVals.wls(1),wls <= trimVals.wls(2)));

                    %select the object data subset that contains the trimmed t values

                    obj(objInd) = obj(objInd).subset('wavelengths',wls);

                else
                    error('Expected all keyword or wavelength range [wl1, wl2] of type double.');
                end

                %trim delays
                if ischar(trimVals.delays)  %this is a do nothing case
                    % Assert correct input to ensure user isn't accidently doing something they're not aware of
                    assert(strcmp(trimVals.delays,'all'),'Expected all keyword or delay range [d1, d2] of type double.');

                elseif isa(trimVals.delays,'double')   %this does the wavelength trim
                    %ensure the user has correct input before trimming
                    assert(length(trimVals.delays)==2, 'Expected delay range [d1, d2] of type double.');
                    trimVals.delays = sort(trimVals.delays);    %ensure delays are in increasing order

                    %find the wavelength range indicies
                    t = obj(objInd).delays.data(:);  %[delays x rpts x gPos]
                    t = t(~isnan(t));
                    t = sort(t);

                    %select t subrange within (inclusive) the trim range
                    t = t(and(t>=trimVals.delays(1),t <= trimVals.delays(2)));

                    %select the object data subset that contains the trimmed t values
                    obj(objInd) = obj(objInd).subset('delays',t);

                else
                    error('Expected all keyword or delay range [d1, d2] of type double.');
                end
            end
            
            %reshape object back to original array size
            obj = reshape(obj,objSize);
        end
        
        function obj = subset(obj, varargin)
        % SUBSET Returns a subset object array closest to the input target ranges.
        % This function returns objects with data limited to the wavelengths and
        % delays closest to the target ranges. If the user desires a subset with
        % wavelength and delay values that exactly match the input ranges, use the
        % interp method.
        %
        % If all wavelengths or delays are removed for a rpt, gpos, or scheme 
        % dimension, then the sizes of the wavelength or delay dimensions are 
        % reduced to remove extra NaN values. The subset ranges are specified by 
        % 'wavelengths',[lower,upper] or 'delays', [lower, upper]. By default, 
        % 'wls' and 'delays' are set to 'all' which does not change the the 
        % elements of the selected dimensions.
        % 
        % obj = obj.SUBSET()
        %   This call does nothing because the default values for 'wavelegnths' and
        %   'delays' is 'all'.
        %
        % obj = obj.SUBSET('wavelengths',wlArray)
        %   Returns a subset of the obj data with wavelengths closest to wlArray 
        %   for all grating positions, repeats, delays, and schemes. With multiple 
        %   grating positions, extra wavelength data is replaced with NaN. Data 
        %   size is adjsuted to remove extra NaN values.
        %
        % obj = obj.SUBSET('delays',tArray)
        %   Returns a subset of the obj data with delays closest to tArray 
        %   for all grating positions, repeats, delays, and schemes. Extra delays 
        %   are replaced with NaN, but usually the data size is adjusted to remove 
        %   the extra NaN values.
        % 
        % obj = obj.SUBSET('wavelengths',wlArray,'delays',tArray)
        % obj = obj.SUBSET('delays',tArray,'wavelengths',wlArray)
        %   Returns a subset of both wavelengths and delays as described above.
        %
        % See Also: TRIM
            
            %define default values
            subVals = struct('wls','all',...
                          'delays','all');
            
            %parse varargin
            if nargin > 1
                for ii = 1:2:(nargin-1)
                    assert(ischar(varargin{ii}),...
                        ['Invalid argument class for name-value pair. Expected class char for name, got ' class(varargin{ii}) '.']);
                    switch varargin{ii}
                        case 'wavelengths'
                            subVals.wls = varargin{ii+1};
                        case 'delays'
                            subVals.delays = varargin{ii+1};
                        otherwise
                            error([varargin{ii} ' is not a valid argument name.']); 
                    end
                end
            end
            
            % Format object array dims into a column for easy looping
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            
            for objInd = 1:objNumel
            
                %subset wavelengths
                if ischar(subVals.wls)  %this is a do nothing case
                    % Assert correct input to ensure user isn't accidently doing something they're not aware of
                    assert(strcmp(subVals.wls,'all'),'Expected all keyword or wavelength range [wl1, wl2] of type double.');

                elseif isa(subVals.wls,'double') && ~isempty(subVals.wls)  %this does the wavelength trim              
                    %get actual indicies and wavelengths from object data. These may be
                    %multi-dim if there are multiple repeats and grating positions
                    wls = obj(objInd).wavelengths.data; %[wls, gpos]
                    [~, wlInd] = nearestVal(wls,subVals.wls,'threshold',0.01*(max(wls(:))-min(wls(:))));               

                    %for easy looping, do the following dim rearrangement:
                    %[pixels, delays, rpts, gpos, schemes] -> [pixels, delays x rpts x schemes, gpos]
                    tmpSpectra = permute(obj(objInd).spectra.data,[1,2,3,5,4]);
                    tmpSpectra = reshape(tmpSpectra,obj(objInd).sizes.nPixels,[],obj(objInd).sizes.nGPos);

                    %Allocate NaN double arrays and place spectra values into it 
                    trimmedSpectra = nan(size(tmpSpectra)); %[pixels, delays x rpts x schemes, gpos]
                    trimmedWls = nan(size(wls)); %[pixels, gpos]

                    %loop over grating positions to sub-select range dicated by wlInd
                    for ii = 1:obj(objInd).sizes.nGPos
                        %remove NaN from wlInd
                        wlIndNoNaN = wlInd(~isnan(wlInd(:,ii)),ii);

                        %copy desired subrange for each grating position into the NaN arrays starting from index 1
                        trimmedWls(1:length(wlIndNoNaN),ii) = wls(wlIndNoNaN,ii);
                        trimmedSpectra(1:length(wlIndNoNaN),:,ii) = tmpSpectra(wlIndNoNaN,:,ii); 
                    end

                    %remove any dims that are all NaN
                    isWlNaN = all(isnan(trimmedWls),2); %all wls are NaN for each gpos, delay, rpt, and scheme
                    isGPosNaN = all(isnan(trimmedWls),1); %all wls are NaN for each wl, delay, rpt, and scheme
                    trimmedWls = trimmedWls(~isWlNaN,~isGPosNaN); %[wls, gpos]
                    trimmedSpectra = trimmedSpectra(~isWlNaN,:,~isGPosNaN); %[pixels, delays x rpts x schemes, gpos]
                    trimmedGPos = obj(objInd).gPos(~isGPosNaN);

                    %update sizes
                    obj(objInd).sizes.nPixels = size(trimmedWls,1);
                    obj(objInd).sizes.nGPos = length(trimmedGPos);

                    %convert spectra back to original dimensions and dim order
                    %[pixels, delays x rpts x schemes, gpos] -> [pixels, delays, rpts, gpos, schemes]
                    trimmedSpectra = reshape(trimmedSpectra,obj(objInd).sizes.nPixels,obj(objInd).sizes.nDelays,obj(objInd).sizes.nRpts,obj(objInd).sizes.nSchemes,obj(objInd).sizes.nGPos); %[pixels, delays, rpts, schemes, gpos]
                    trimmedSpectra = permute(trimmedSpectra,[1,2,3,5,4]); %[pixels, delays, rpts, gpos, schemes]

                    %add data back to obj(objInd)ect
                    obj(objInd).wavelengths.data = trimmedWls;
                    obj(objInd).spectra.data = trimmedSpectra;
                    obj(objInd).gPos = trimmedGPos;

                else
                    error('Expected all keyword or wavelengths array of type double.');
                end

                %subset delays
                if ischar(subVals.delays)  %this is a do nothing case
                    % Assert correct input to ensure user isn't accidently doing something they're not aware of
                    assert(strcmp(subVals.delays,'all'),'Expected all keyword or delay range [d1, d2] of type double.');

                elseif isa(subVals.delays,'double') && ~isempty(subVals.delays)   %this does the delay subset               
                    %find the wavelength range indicies
                    t = reshape(obj(objInd).delays.data, obj(objInd).sizes.nDelays, []);  %[delays, rpts x gPos]
                    [~,tInd] = nearestVal(t,subVals.delays); %tInd is [delays, rpts x gPos]

                    %for easy looping, do the following dim rearrangement:
                    %[pixels, delays, rpts, gpos, schemes] -> [delays, pixels x schemes, rpts x gpos]
                    tmpSpectra = permute(obj(objInd).spectra.data,[2,1,5,3,4]);
                    tmpSpectra = reshape(tmpSpectra,obj(objInd).sizes.nDelays,obj(objInd).sizes.nPixels*obj(objInd).sizes.nSchemes,[]);

                    %Allocate NaN double arrays and place spectra values into it 
                    trimmedSpectra = nan(size(tmpSpectra)); %[delays, pixels x schems, rpts x gpos]
                    trimmedDelays = nan(size(t)); %[delays, rpts x gpos]

                    %loop over grating positions and repeats to sub-select range dicated by wlInd
                    for ii = 1:size(tInd,2)
                        %remove NaN from tInd
                        tNoNaN = tInd(~isnan(tInd(:,ii)),ii);

                        %copy desired subrange for each grating position into the NaN arrays starting from index 1
                        trimmedDelays(1:length(tNoNaN),ii) = t(tNoNaN,ii); %[delays, rpts x gpos]
                        trimmedSpectra(1:length(tNoNaN),:,ii) = tmpSpectra(tNoNaN,:,ii); %[delays, pixels x schems, rpts x gpos]
                    end

                    %remove any dims that are all NaN
                    isDelayNaN = all(isnan(trimmedDelays),2); %all delays are NaN for each rpt and gpos
                    trimmedDelays = trimmedDelays(~isDelayNaN,:); %[delays, rpts x gpos]
                    trimmedSpectra = trimmedSpectra(~isDelayNaN,:,:); %[delays, pixels x schems, rpts x gpos]

                    %update sizes
                    obj(objInd).sizes.nDelays = size(trimmedDelays,1);

                    %convert spectra back to original dimensions and dim order
                    %[delays, pixels x schemes, rpts x gpos] -> %[pixels, delays, rpts, gpos, schemes]
                    trimmedDelays = reshape(trimmedDelays,obj(objInd).sizes.nDelays,obj(objInd).sizes.nRpts,obj(objInd).sizes.nGPos); %[delays, rpts, gPos]
                    trimmedSpectra = reshape(trimmedSpectra,obj(objInd).sizes.nDelays,obj(objInd).sizes.nPixels,obj(objInd).sizes.nSchemes,obj(objInd).sizes.nRpts,obj(objInd).sizes.nGPos); %[delays, pixels, schemes, rpts, gpos]
                    trimmedSpectra = permute(trimmedSpectra,[2,1,4,5,3]); %[pixels, delays, rpts, gpos, schemes]

                    %add data back to object
                    obj(objInd).delays.data = trimmedDelays;
                    obj(objInd).spectra.data = trimmedSpectra;

                else
                    error('Expected all keyword or delay array of type double.');
                end
            end
            
            %reshape object back to original array size
            obj = reshape(obj,objSize);
        end
        
        function obj = interp(obj, varargin)
        % INTERP interpolates spectral data on user specified axes. This method
        % wraps MATLAB's interpn function.
        %
        % Use name-value pairs to specify axes to interpolate, followed by the 
        % interpolation values. In addition, you can pass interpn methods and 
        % extrapval parameters as name-value pairs.
        %
        % Notes: 
        % -This method interpolates repeats, grating positions, and schemes
        % seperately. 
        % -When interpolating wavelengths over multiple grating positions, both 
        % grating positions are interpolated onto the same axis, which may lead to 
        % unexpected behavior when using extrapolation. In these, cases, it is 
        % recommended to stitch before using interpolation.
        % -This method handles NaN values by interpolating them to NaN.
        %
        % obj = obj.INTERP()
        %   Do not use this call directly. This will interpolate data onto its own
        %   axes. Note, this call does not return an error.
        %
        % obj = obj.INTERP('wavelengths', wlAr)
        %   Interpolates object data wavelengths onto vector wlAr.
        % 
        % obj = obj.INTERP('delays', dAr)
        %   Interpolates object data delays onto bector dAr.
        %
        % obj = obj.INTERP('wavelengths', wlAr, 'delays', dAr)
        % obj = obj.INTERP('delays', dAr, 'wavelengths', wlAr)
        %   Does a 2D interpolation onto wavelengths and delay arrays wlAr and dAr.
        %
        % obj = obj.INTERP(__,interpMethod)
        % obj = obj.INTERP(__,interpMethod,extrapMethod)
        %   Additional arguments that set the griddedInterpolant interpolation and
        %   extrapolation methods. The defaults are 'linear' for interpolation and 
        %   'none' for extrapolation.
        %
        % See Also: GRIDDEDINTERPOLANT
            
            % setup an input parser scheme
            p = inputParser();
            p.KeepUnmatched = true;
            p.addParameter('wavelengths',[],@(v) validateattributes(v,{'double'},{'vector'}));
            p.addParameter('delays',[],@(v) validateattributes(v,{'double'},{'vector'}));
            
            % filter varargin for griddedInterpolant keywords first
            [vOut, mInterp, mExtrap] = filterGInterpMethod(varargin,'linear','none');
            
            % parse remaining inputs
            p.parse(vOut{:});
            
            % Setup a griddedInterpolant object with user defined interpolation and extrapolation
            F = griddedInterpolant();
            F.Method = mInterp;
            F.ExtrapolationMethod = mExtrap;
            
            % Format object array dims into a column for easy looping
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            
            % Loop over object elements
            for objInd = 1:objNumel
                % Extract data for numerical processing
                s = obj(objInd).spectra.data;
                t = obj(objInd).delays.data;
                l = obj(objInd).wavelengths.data;
                
                % Convert array sizes of t and l to match the size of s for easy vectorization
                % s old: [pixels, delays, rpts, g pos, schemes]
                % s new: [pixels, delays, rpts x g pos x schemes]
                % t old: [delays, rpts, g pos]
                % t new: [delays, rpts x g pos x schemes]
                % l old: [pixels, g pos]
                % l new: [pixels, rpts x g pos x schemes]
                t = reshape(explicitExpand(t,sizePadded(s,[2:5])),obj(objInd).sizes.nDelays,[]);
                l = reshape(explicitExpand(permute(l,[1,3,2]),sizePadded(s,[1 3:5])),obj(objInd).sizes.nPixels,[]);
                s = reshape(s,obj(objInd).sizes.nPixels,obj(objInd).sizes.nDelays,[]);
                
                % Define new sizes for outputs, which will depend on what is being interpolated
                % Number of new wavelength elements
                if isempty(p.Results.wavelengths)
                    szl = size(l,1);
                else
                    szl = numel(p.Results.wavelengths);
                end
                
                % Number of new delay elements
                if isempty(p.Results.delays)
                    szt = size(t,1);
                else
                    szt = numel(p.Results.delays);
                end
                
                % The number of extra dim array elements
                nExtra = size(s,3);
                
                % For efficient vectorization, initialize output arrays
                lNew = zeros(szl,nExtra);
                tNew = zeros(szt,nExtra);
                sNew = zeros(szl,szt,nExtra);
                
                % Loop over the extra dims
                for ii = 1:nExtra                   
                    % Handle no interpolation along one of the dims
                    if isempty(p.Results.wavelengths)
                        lNew(:,ii) = l(:,ii);
                    else
                        lNew(:,ii) = p.Results.wavelengths;
                    end
                    
                    if isempty(p.Results.delays)
                        tNew(:,ii) = t(:,ii);
                    else
                        tNew(:,ii) = p.Results.delays;
                    end
                    
                    % In addition, MATLAB's interp requires that data points are sorted
                    [t(:,ii), tI] = sort(t(:,ii));
                    [l(:,ii), lI] = sort(l(:,ii));
                    s(:,:,ii) = s(lI,tI,ii);

                    % sort the new values as well
                    [lNew(:,ii), lNewI] = sort(lNew(:,ii));
                    [tNew(:,ii), tNewI] = sort(tNew(:,ii));
                    
                    % Generate grid vectors
                    gridIn = {l(:,ii), t(:,ii)};
                    gridOut = {lNew(:,ii), tNew(:,ii)};
                    
                    % find singleton dims in grid vectors-- interpolation requires at least 2 pts in each dim
                    isSing = sizePadded(s,1:numel(gridIn))==1;
                    
                    % Update grid vectors, values, and evaluate on new grid
                    F.GridVectors = gridIn(~isSing);    %set interpolant grid
                    F.Values = s(:,:,ii);      %set interpolant values
                    sNew(:,:,ii) = F(gridOut(~isSing)); %evaluate on new gride
                    
                    % Reconstruct the spectra matrix
                    % First, unsort the sorted dims
                    lNew(lNewI,ii) = lNew(:,ii);
                    tNew(tNewI,ii) = tNew(:,ii);
                    sNew(lNewI,tNewI,ii) = sNew(:,:,ii);                   
                end
                
                % After for loop, undo reshape and explicit expand operation
                % s old: [pixels, delays, rpts x g pos x schemes]
                % s new: [pixels, delays, rpts, g pos, schemes]
                % t old: [delays, rpts x g pos x schemes]
                % t new: [delays, rpts, g pos]
                % l old: [pixels, rpts x g pos x schemes]
                % l new: [pixels, g pos]
                % Undo reshape operations
                sNew = reshape(sNew, szl, szt, obj(objInd).sizes.nRpts, obj(objInd).sizes.nGPos, obj(objInd).sizes.nSchemes);
                lNew = reshape(lNew, szl, obj(objInd).sizes.nRpts, obj(objInd).sizes.nGPos, obj(objInd).sizes.nSchemes);
                tNew = reshape(tNew, szt, obj(objInd).sizes.nRpts, obj(objInd).sizes.nGPos, obj(objInd).sizes.nSchemes);
                
                % undo explicit expand operations
                lNew = permute(lNew(:,1,:,1),[1,3,2,4]);
                tNew = tNew(:,:,:,1);
                
                % Update object data with new wavelengths, delays, and
                % spectra values
                obj(objInd).spectra.data = sNew;
                obj(objInd).wavelengths.data = lNew;
                obj(objInd).delays.data = tNew;
                
                % Update object sizes
                obj(objInd).sizes.nPixels = szl;
                obj(objInd).sizes.nDelays = szt;
            end
            
            %convert object array back to original size
            obj = reshape(obj,objSize);
            
        end
        
        function obj = prune(obj, varargin)
        % PRUNE sets selected bad data points to NaN. Currently, PRUNE can be run 
        % only by specifying a logical array the same size as the object spectra
        % or by specifying a cell array of logical being pruned arrays, where the 
        % cell array is the same size as the object array and each element's 
        % logical array is the same size as obj(elem).spectra.
        %
        % obj = obj.PRUNE(logicalArray)
        %   Sets indicies specified by logicalArray in obj.spectra to NaN.
        %   logicalArray must be the same size as obj.spectra
        %
        % obj = obj.PRUNE(logicalArrayCell)
        %   Prunes each element of object according to the elements of logicalArrayCell.
        %   size(obj) must be the same as size(logicalArrayCell). This call is the same 
        %   looping over elements of obj and logicalArrayCell and making the call above:
        %   obj(elem) = obj(elem).PRUNE(logicalArrayCell(elem))

            p = inputParser();
            
            p.addOptional('pruneRule','',@(s) ischar(s));
            p.addRequired('pruneData',@(c) iscell(c) || islogical(c));
            
            p.parse(varargin{:});
            
            % Format object array dims into a column for easy looping
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            
%             if ~iscell(p.Results.pruneData) || ~islogical(p.Results.pruneData{1})
%                 dimOrder = {'pixels','delays','rpts','gpos','schemes'};
%                 
%                 pruneStr = strsplit(p.Results.pruneRule);
%                 pruneData = p.Results.pruneData;
%                 
%                 logicalArray = cell(objSize);  %default value for logical array cell
%                 
%                 %determine pruneData nest depth
%                 nestDepth = 1;
%                 tmp = pruneData;
%                 isIndCell = cellfun('isclass',tmp,'cell');
%                 while any(isIndCell(:))
%                     cellInd = find(isIndCell);
%                     tmp = tmp{cellInd(1)};
%                     isIndCell = cellfun('isclass',tmp,'cell');
%                     nestDepth = nestDepth + 1;
%                 end
%                 
%                 %ensure that the pruneStr has an entry for each nest level
%                 assert(length(pruneStr)==nestDepth,['The nested levels in the cell tree must '...
%                     'match the number of entries in the prune string. Nested levels: '...
%                     num2str(nestDepth) ' Prune strings: ' num2str(length(pruneStr))]);
%                 
%                 if strcmp(pruneStr{1},'obj')
%                     pruneStr = pruneStr(2:end); %remove obj from pruneStr
%                     
%                     %determine if pruneData explicitly specifies object index
%                     isIndex = cellfun('isclass',pruneData,'double');  
%                     if any(isIndex)    %explicit object index -- convert to implicit
%                         
%                     end
%                     
%                     %pruneData shold be a cell array the same size as obj and logical Array
%                     
%                 else
%                     %convert pruneData to specify object index as outermost cell
%                     pruneData = p.Results.pruneData;
%                 end
%                 
%                 %convert pruneData to column for easy looping
%                 pruneData = pruneData(:);
%                 pruneNumel = numel(pruneData);
%                 
%                 %loop over prune object index
%                 for pruneInd = 1:pruneNumel
%                     %initialize prune logical array. False means keep the
%                     %data point, true means prune it (set to NaN)
%                     logicalArray{pruneInd} = false(size(obj(pruneInd).spectra.data));
%                     
%                     %loop over nested levels
%                     for ii = 1:nestDepth
%                         
%                     end
%                 end
%                 
%                 
%             else
               logicalArray = p.Results.pruneData; 
               if ~iscell(logicalArray)
                   logicalArray = {logicalArray};
               end
%             end
            
            %Prune object data
            for objInd = 1:objNumel
               %create local copy of spectra data for pruning
               tmpSpectra = obj(objInd).spectra.data;
               tmpSpectraStd = obj(objInd).spectra_std.data;
               
               %convert spectra data to column for easy indexing
               spectraSize = size(tmpSpectra);
               tmpSpectra = tmpSpectra(:);
               tmpSpectraStd = tmpSpectraStd(:);
               
               %depending on number of entries in logicalArray cell, set
               %specified indicies to NaN
               if length(logicalArray)==1
                   tmpSpectra(logicalArray{1}(:)) = NaN;
                   tmpSpectraStd(logicalArray{1}(:)) = NaN;
               else
                   tmpSpectra(logicalArray{objInd}(:)) = NaN;
                   tmpSpectraStd(logicalArray{objInd}(:)) = NaN;
               end
               
               %reassign reshaped pruned spectra back to object data
               obj(objInd).spectra.data = reshape(tmpSpectra,spectraSize);
               obj(objInd).spectra_std.data = reshape(tmpSpectraStd,spectraSize);
            end
            
            %convert object array back to original size
            obj = reshape(obj,objSize);
            
        end
        
        function [obj, t0Arr] = findT0(obj, varargin)
        % FINDT0 attempts to find the true t0 inside the dataset by fitting a
        % specified wavelength to an appropriate function, such as a sigmoid. The 
        % user also has an option to specifiy a custom fit function.
        %
        % todo: add logic that keeps track of whether t0 has been corrected or not
        %
        % obj = obj.FINDT0()
        %   Finds the t0 for the dataset by fitting the central wavelength to a 
        %   sigmoid function, dOD = a+b*0.5*(1+erf(sqrt(0.5)*(t-t0)/s)), where a is
        %   a baseline, b is the signal amplitude, and s is the standard deviation
        %   rise-time (defined by the pump-probe convolution).
        %
        % obj = obj.FINDT0(varargin)
        %   Finds the t0 for the dataset with optional name-value pairs:
        %   'tRange': (2 element numeric vector) the delay range to fit for t0. The
        %       default value is either  +/-min(t) if t is negative or t:10*minStep
        %       if t is positive and where minStep is the smallest delay step in 
        %       the data.
        %   'wlAr': (numeric vector) wavelengths at which to perform the t0 fit. 
        %       The default is the center-most wavelength in the data.
        %   'fitFun': (function handle) A custom function handle to fit the t0 with
        %       of the form: t0 = f(x,y). The default is the third element of 
        %       lsqFitSigmoid.
        %
        % [obj, t0Array] = obj.FINDT0(__)
        %   Additionally returns the t0 fit data in a cell array where the array
        %   size is the size of obj and each element of the cell array has a size
        %   of [numel(wlAr),nRpts,nGPos].
        %
        % See Also: LSQFITSIGMOID, LSQNONLIN
            
            % Format object array dims into a column for easy looping
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            t0Arr = cell(objNumel,1);           
            
            % Format varargin using input parser
            p = inputParser;
            p.FunctionName = 'findT0';
            p.addParameter('tRange', [], @(p) (isnumeric(p) && numel(p)==2) || isempty(p));
            p.addParameter('wlAr', [], @(p) (isvector(p) && isnumeric(p)) || isempty(p));
            p.addParameter('fitFun',@(x,y) sum(lsqFitSigmoid(x, y).*[0,0,1,0]), @(p) isa(p,'function_handle'));
           
            % Parse arguemnts, results will be in p.Results
            p.parse(varargin{:});
            results = p.Results;
            
            % Loop over individual object elements
            for objInd = 1:objNumel
               
               % Default wlAr is the center-most wavelength
               if isempty(p.Results.wlAr)
                   minWl = min(obj(objInd).wavelengths.data,[],'all');
                   maxWl = max(obj(objInd).wavelengths.data,[],'all');
                   results.wlAr = 0.5*(minWl + maxWl);
               end
               
               % Default tRange is:
               if isempty(p.Results.tRange)
                   minDelay = min(obj(objInd).delays.data,[],'all','omitnan');
                   if minDelay < 0  %-min delay to + min delay if min delay is negative
                      results.tRange = [minDelay, abs(minDelay)]; 
                   else %min delay to 10x the minimum step away from the min delay if not negative
                      minDelayStep = min(abs(diff(obj(objInd).delays.data,1,1)),[],'all','omitnan');
                      results.tRange = minDelay + [0, 10*minDelayStep];
                   end
               end
               
               % Subset and trim the object to the desired wavelength and delay range
               tmpObj = obj(objInd).subset('wavelengths',results.wlAr);
               tmpObj = tmpObj.trim('delays',results.tRange);
               
               %convert object into double array
               t = tmpObj.delays.data;
               spectData = tmpObj.spectra.data;
               
               %convert spectra dims
               %from [pixels, delays, rpts, grating pos, schemes]
               %into [delays, pixels x rpts x grating pos x schemes]
               nExtraDim = tmpObj.sizes.nPixels*tmpObj.sizes.nRpts*tmpObj.sizes.nGPos*tmpObj.sizes.nSchemes;
               spectData = permute(spectData,[2,1,3,4,5]);
               spectData = reshape(spectData,tmpObj.sizes.nDelays,nExtraDim);
               
               %convert t dims
               %from [delays, repeats, grating pos]
               %into [delays, pixels x rpts x grating pos x schemes]
               t = permute(t,[1,4,2,3,5]); %[delays, 1, rpts, grating pos, 1]
               t = repmat(t,[1,tmpObj.sizes.nPixels,1,1,tmpObj.sizes.nSchemes]); %[delays, pixels, rpts, grating pos, schemes]
               t = reshape(t,tmpObj.sizes.nDelays,nExtraDim); %[delays, pixels x rpts x grating pos x schemes]
               
               %loop over extra dims and fit 
               t0Tmp = zeros(1,nExtraDim);             
               for ii = 1:nExtraDim
                   % Runs the fit function. By default this is lsqFitSigmoid, 
                   % which fits data to y = a+b*0.5*(1+erf(sqrt(0.5)*(x-x0)/s));
                   % and returns the third element of fp, [a, b, x0, s]
                   t0Tmp(1,ii) = results.fitFun(t(:,ii),spectData(:,ii));
               end
               
               %convert t0 dims
               %from [1,pixels x rpts x grating pos x schemes]
               %to [pixels, rpts, grating pos, schemes]
               %and store in t0 output and object member data
               t0Arr{objInd} = reshape(t0Tmp,tmpObj.sizes.nPixels,tmpObj.sizes.nRpts,tmpObj.sizes.nGPos,tmpObj.sizes.nSchemes);
               obj(objInd).t0 = doubleWithUnits(t0Arr{objInd},obj(objInd).t0);
            end
            
            % convert object array back to original size
            obj = reshape(obj,objSize);
            t0Arr = reshape(t0Arr,objSize);
        end
        
        function obj = correctT0(obj, varargin)
        % CORRECTT0 adjusts the delay values according to t0 fit information stored
        % in the object member data. If the t0 fit has not been performed, this
        % method will call findT0 with it's default options. If multiple t0s
        % are available for any object, this method will by default correct the
        % delays with the average t0.
        %
        % todo: add logic that keeps track of whether t0 has been corrected or not
        %
        % obj = obj.CORRECTT0()
        %   Corrects the delays by an average t0 for each element of obj.
        % 
        % obj = obj.CORRECTT0('average', false)
        %   Corrects the delays by a t0 amount specific to the grating position and
        %   repeat, for each element of obj.
        %
        % See Also: FINDT0
            
            % Format object array dims into a column for easy looping
            objSize = size(obj);
            objNumel = numel(obj);
            obj = obj(:);
            
            % Format varargin using input parser
            p = inputParser;
            p.FunctionName = 'correctT0';
            p.addParameter('average', true, @(l) islogical(l));
            
            % Parse arguemnts, results will be in p.Results
            p.parse(varargin{:});
            
            % Loop over individual object elements
            for objInd = 1:objNumel
                % Make sure t0 has been found. todo: use flag inside object to determine
                if all(obj(objInd).t0.data == 0)
                   obj(objInd) = obj(objInd).findT0;
                end
                
                if p.Results.average
                    % average all t0 values if flagged
                    obj(objInd).t0.data = mean(obj(objInd).t0.data,'all','omitnan');
                    
                    % update all delays equally by averaged t0 value
                    obj(objInd).delays.data = obj(objInd).delays.data - obj(objInd).t0.data;
                else
                    % Correct each grating position and repeat individually
                    % average pixel t0 values for individual grating positions
                    obj(objInd).t0.data = mean(obj(objInd).t0.data,1,'omitnan');
                    
                    % update all delays with implicit array dim expansion for t0
                    obj(objInd).delays.data = obj(objInd).delays.data - obj(objInd).t0.data;
                end
                
            end
            
            % update object state to t0 has been corrected
            % obj.flags.t0Corr = true;
            
            % convert object array back to original size
            obj = reshape(obj,objSize);
        end
        
        function [procdTable, lookupTable] = dbCommit(obj, varargin)
% COMMIT saves the elements in obj to file and logs their location and 
% metadata to the database.

            % parse required and optional user inputs
            p = inputParser();
            
            p.addRequired('conn');          %The database connection object
            p.addRequired('procDataTable'); %the name of the table that logs processed data
            
            p.addParameter('path',pwd);     %default is the current working directory
            p.addParameter('prefix','');    %use prefix to prefix the short name for all object array elements
            p.addParameter('fkStruct',struct([])); %foriegn key struct to assign values to all rows of a fk column
            p.addParameter('colStruct',struct([])); %column value struct to assign values to all rows of a column
            
            p.parse(varargin{:}); %Parse inputs and store into struct p.Results
            
            % Format object array dims into a column for easy looping
            objNumel = numel(obj);
            obj = obj(:);
            
            % Generate a list of columns to include into the commit--------
            colNames = {'FileName','FilePath','ShortName','FileTypeID','TimeStamp'}; %Cols that are autofilled
            
            % add user columns:
            % non-fk cols
            if ~isempty(p.Results.colStruct)
               colFieldNames = fieldnames(p.Results.colStruct);
               colNames = [colNames, colFieldNames(:)'];
            end
            
            % fk-cols
            if ~isempty(p.Results.fkStruct)
               colFieldNames = {p.Results.fkStruct.fkCol};
               colNames = [colNames, colFieldNames(:)'];
            end
            
            % Before starting the commit, check to make sure database------
            % tables match what is being requested in the commit
            
            % Fetch table information to ensure that the table containsvalid column names
            conn = p.Results.conn;
            tmpTable = conn.fetch(['SELECT * FROM ', p.Results.procDataTable, ' WHERE ID = 0;']);
            
            % Ensure that all columns being requested for the commit exist in the procDataTable
            % and order colNames in the same order as in the db table (for display purposes)
            pTCols = tmpTable.Properties.VariableNames; %col names in db table
            colOrder = zeros(size(colNames)); %col order for old names
            
            % Loop through commit col names
            for ii = 1:numel(colNames)
                inds = strcmp(colNames{ii},pTCols); %returns commit col name index in db table
                assert(any(inds),'Col %s was not found in table %s.',colNames{ii}, p.Results.procDataTable); %assert an index exists
                colOrder(ii) = find(inds); %assigns index position to colOrder
            end
            
            % converts db table order into commit col order
            [~, colOrder] = sort(colOrder); 
            
            % Fill in values for columns in the commit table---------------
            % Generate formatted timestamps
            tNow = datetime('now', 'format', "yy-MM-dd_HH'h'mm'm'ss's'"); % for file name
            fTS = char(tNow);

            tNow.Format = 'd/M/yyyy h:mm:ss a'; % for database
            dbTS = repmat({char(tNow)},objNumel,1); %TimeStamp
            
            % Generate char cell arrays to populate known fields in the tables
            shortNames = strcat(p.Results.prefix,{' '},{obj.shortName})';   
            fileNames = strcat(fTS, '_', validateFileNames(shortNames), '.mat');
            filePaths = repmat({p.Results.path},objNumel,1);    
            
            % Determine fileType foreign key
            fileTypeTable = conn.fetch("SELECT ID, ShortName FROM FileTypes WHERE ShortName = 'tsObj';");
            assert(~isempty(fileTypeTable), "Could not find 'tsObj' filetype in database FileTypes table.");
            fileTypeID = repmat(fileTypeTable.ID(1),objNumel,1);    %fileTypeID
            
            % Build table input cell array
            tableInputs = {fileNames,filePaths,shortNames,fileTypeID,dbTS};
            
            % Append extra table inputs from colStruct and fkStruct inputs
            % non fk-cols
            if ~isempty(p.Results.colStruct)
                colFieldNames = fieldnames(p.Results.colStruct);
                for ii = 1:numel(colFieldNames)
                    % Append to table inputs the contents of colStruct by field
                    tableInputs = [tableInputs, {repmat({p.Results.colStruct(1).(colFieldNames{ii})},objNumel,1)}];
                end
            end
            
            % fk-cols
            if ~isempty(p.Results.fkStruct)
               for ii = 1:size(p.Results.fkStruct,1)
                   % Query the pk table for fk info
                   tmpTable = conn.fetch(['SELECT ', p.Results.fkStruct(ii).pkCol,...
                                         ' FROM ', p.Results.fkStruct(ii).pkTable,... 
                                         ' WHERE ', p.Results.fkStruct(ii).pkDispCol ' = ''', p.Results.fkStruct(ii).pkDispVal, ''';']);
                   % Append fk info directly to tableInputs (this should always be an integer)
                   tableInputs = [tableInputs, {repmat({tmpTable{1,1}},objNumel,1)}];
               end
            end
            
            % Rearrange column order for display
            tableInputs = tableInputs(colOrder);
            colNames = colNames(colOrder);
            
            % Build table--table throws error if there are duplicate column/variable names
            tableConstructor = [tableInputs(:); {'VariableNames'}; {colNames}];
            procdTable = table(tableConstructor{:});
            %baseNames = {obj.name}';
            
            lookupTable = [];
            
        end
    end
    
    
end